# フォルダ構造について

## internal以下のファイル構造

```
.
├── domain
│   ├── common
│   ├── messages
│   ├── model
│   └── service
├── infra
│   ├── config
│   ├── external
│   │   └── telemetry
│   └── persistence
│       ├── db
│       ├── postgresql
│       ├── repository
│       └── query
├── presentation
│   ├── middleware
│   └── handler
└── usecase
    ├── command
    |   └── hoge_command.go
    └── query
        ├── hoge_query.go
        └── dto
```

## domain

コアロジック

ここには純粋なビジネスロジックを記述します。
DBアクセスやHTTPなど、ビジネスロジックと直接関係のないことはここには記述しません。

```tree
domain
 ├─ user
 |   ├─ user.go <- entity
 |   ├─ repository
 |   │  └─ user_repository.go
 |   ├─ service
 |   │  └─ user_duplication_check_domain_service.go
 |   └─ value
 |      └─ user_id.go
 └─ team
     ├─ team.go <- userの上位集約
     ├─ repository
     │  └─ team_repository.go
     └─ service
```

基本的にエンティティ、値オブジェクトを集約ごとに切り分けます。

### Entity

値が変わっても同一性が保証されるものオブジェクトはエンティティとなります。
例えば、ユーザーなら名前が変わってもIDが同一なら同一のユーザーということがわかるため、エンティティとなります。

基本的にEntityに関わるビジネスロジックは全てここに記述します。

配置規則としては、集約ルートに一つエンティティを置きます。

また、複数の集約が必要な場合は別パッケージに切り出し、それをエンティティとする。

### ValueObject

値に意味があるオブジェクトは値オブジェクトとなります。
このプロジェクトでは基本的に値オブジェクトは採用しませんが、値にビジネスロジックが明確にある場合は値オブジェクトを採用します。
基本的には工数が爆発するため使用しないでください。

### Repository

集約ごとのミューテーションに関する永続化処理の振る舞いをここに記述。
例えば`Create`, `Update`などはこのリポジトリに記述しますが、`FindByID`など

### DomainService

Entity自体で表すことに違和感があるものについてはDomainServiceを用います。
例えば、`ユーザー名の重複を調べる`などのアクションは明確にユーザーのビジネスロジックですが、ユーザーエンティティ自体が行うロジックではありません。このようなものはDomainServiceに記述します。

このサービスが依存できるのはドメイン層のオブジェクトおよびインターフェイスのみです。
サービスメソッドは動作を明確にし、ドメインオブジェクトに記述できるロジックはできるだけドメインオブジェクトに記述してください。
例えば、ユーザー名変更などもドメインサービスに記述することはできますが、このようなものは基本的にエンティティに記述すること。

命名規則

`[処理内容]_domain_service.go`

## UseCase

```tree
usecase
 ├─ command
 │   └─ edit_user_profile_command.go
 └─ query
     ├─ dto
     │  └─ user
     └─ user
        └─ list_friends_query_service.go
```

### command

ここではミューテーションを伴う操作を行う場合にコマンドを使用する。
基本的には一般的なApplicationServiceとして実装しても良い。

コマンド入力時の引数はDTOとしてもしなくても良い。
DTOを独自に作る場合は以下の命名規則に従う。

`[操作]Command`

CQRSにおけるコマンドは一般的にエラーのみを返すことを期待されている。しかし、このプロジェクトでは戻り値を返すことも許可することとする。
一般的にCQRSはkafkaなどのMQを使用したマイクロサービスによって実装される。この時、コマンドサービスで戻り値を返したところで非同期に処理が行われるためそもそもコマンドには戻り値がないというのは正しい。
しかし、MQを使用しないプロジェクトにおいてはコマンドないで処理の終了を検知することができるし、むしろレプリケーションラグなどを考慮するとコマンドで返した方がよさそう。

ハンドラについて

ファイルを分割すると無駄にファイル間の移動が多くなるため、基本的にハンドラは同一のファイルに含める。
コマンドモデルはDomain層に任せる。

命名規則

フォルダは集約ごとに分け、サフィックスに_commandをつける。
ファイル名は単純なアクション名のみにする。

```text
command
    -> domain_command
        -> action.go
```

パッケージ名：パッケージ名と同様`domain_command`とする。

### query

複数集約にまたがる結果を返す場合が多いため、DTOは一つのフォルダに集約する。
これにより、クエリサービスでは柔軟なデータ取得が可能となる。

QueryServiceの実装は後述するインフラ層にて行う。
実装をインフラ層で行うことにより、複雑なクエリを直接行うことが可能となり、実装が楽になるメリットがある。

QueryServiceではドメインオブジェクトを使用しない。
