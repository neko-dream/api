# フォルダ構造について

## internal以下のファイル構造

```tree
.
├── domain
│   ├── common
│   ├── messages
│   ├── model
│   └── service
├── infra
│   ├── config
│   ├── external
│   │   └── telemetry
│   └── persistence
│       ├── db
│       ├── postgresql
│       ├── repository
│       └── query
├── presentation
│   ├── middleware
│   └── handler
└── usecase
    ├── command
    |   └── hoge_command.go
    └── query
        ├── hoge_query.go
        └── dto
```

## domain

ここには純粋なビジネスロジックを記述します。
DBアクセスやHTTPなど、ビジネスロジックと直接関係のないことは、ここには記述しないようにします。

```tree
domain
 ├─ user
 |   ├─ user.go <- entity
 |   ├─ repository
 |   │  └─ user_repository.go
 |   ├─ service
 |   │  └─ user_duplication_check_domain_service.go
 |   └─ value
 |      └─ user_id.go
 └─ team
     ├─ team.go <- userの上位集約
     ├─ repository
     │  └─ team_repository.go
     └─ service
```

基本的には、エンティティや値オブジェクトを集約ごとに切り分けます。

### Entity

値が変わっても同一性が保証されるオブジェクトはエンティティとなります。
たとえば、ユーザーの場合、名前が変わってもIDが同一であれば同一のユーザーだと判断できるため、これはエンティティとなります。

基本的に、エンティティに関わるビジネスロジックはすべてここに記述します。もしエンティティ内のオブジェクトの引数を呼び出すような場合があってもそれを呼ばずエンティティのメソッドとすべきです。

配置規則としては、集約ルートにひとつエンティティを置きます。
また、複数の集約が必要な場合は別パッケージに切り出し、それをエンティティとして扱います。

### ValueObject

値に意味があるオブジェクトは値オブジェクトとなります。
このプロジェクトでは基本的に値オブジェクトは採用しませんが、値にビジネスロジックが明確にある場合には、値オブジェクトを採用します。
ただし、基本的には工数が大きくなるため、むやみに使用しないようにしてください。

### Repository

データアクセスの振る舞いを記述します。戻り値にはドメインオブジェクトを取るようにし、実装はインターフェイス層に記述します。
ミューテーションに係る処理の場合も引数にはドメインオブジェクトを取り、詳細な処理はインターフェイス層で記述します。
注意点としては、基本的にリポジトリには最低限の振る舞いのみを記述するように注意する必要があります。例えば単純な`Create`の処理内に重複検知の処理が入っていた場合、これは`DomainService`にて記述すべきです。また、`ChangeName`のようなドメインオブジェクトに対する副作用を表す振る舞いはドメインオブジェクト自身のメソッドとし、`Repository`では単純な`Update`をすべきです。

### DomainService

ビジネスロジックをエンティティのメソッドとして表すことに違和感があるものについては`DomainService`に記述します。
たとえば、ユーザーの重複チェックなどのアクションはユーザーのビジネスロジックではありますが、ユーザーエンティティ自体が行うロジックではない場合に該当します。
このようなものは`DomainService`に記述します。

このサービスが依存できるのはドメイン層のオブジェクトおよびインターフェイスのみです。
サービスメソッドは動作を明確にし、ドメインオブジェクトに記述できるロジックはできるだけドメインオブジェクトに記述してください。
たとえば、ユーザー名の変更なども`DomainService`に記述することはできますが、原則としてエンティティ側に記述することを推奨します。

命名規則

`[処理内容]_domain_service.go`

## UseCase

```tree
usecase
 ├─ command
 │   └─ edit_user_profile_command.go
 └─ query
     ├─ dto
     │  └─ user
     └─ user
        └─ list_friends_query_service.go
```

### command

ここではミューテーションを伴う操作を行う場合にコマンドを使用する。
基本的には一般的なApplicationServiceとして実装しても良い。

コマンド入力時の引数はDTOとしてもしなくても良い。
DTOを独自に作る場合は以下の命名規則に従う。

`[操作]Command`

CQRSにおけるコマンドは、一般的にエラーのみを返すことが期待されていますが、このプロジェクトでは戻り値を返すことも許可しています。
これは、通常のCQRSがkafkaなどのMQを使用したマイクロサービスとして実装される場合、コマンドサービスで戻り値を返しても非同期に処理が行われるため無意味であるという背景があります。
しかし、本プロジェクトのようにMQを使用しない場合は、コマンド内で処理の終了を検知できるため、むしろレプリケーションラグなどを考慮するとコマンドで戻り値を返したほうがよいケースもあると考えています。

ハンドラについて

ファイルを分割すると、ファイル間の移動が多くなってしまうため、基本的にハンドラは同一のファイルに含めます。
コマンドモデルはDomain層に任せます。

命名規則

フォルダは集約ごとに分け、サフィックスに_commandを付けます。
ファイル名は単純なアクション名のみとします。

```text
command
    -> domain_command
        -> action.go
```

パッケージ名：パッケージ名と同様`domain_command`とする。

### query

複数集約にまたがる結果を返す場合が多いため、DTOは一つのフォルダに集約する。
これにより、クエリサービスでは柔軟なデータ取得が可能となる。

QueryServiceの実装は後述するインフラ層にて行う。
実装をインフラ層で行うことにより、複雑なクエリを直接行うことが可能となり、実装が楽になるメリットがある。

QueryServiceではドメインオブジェクトを使用しない。
