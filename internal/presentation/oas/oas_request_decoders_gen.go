// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"io"
	"mime"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.uber.org/multierr"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func (s *Server) decodeCreateOrganizationAliasRequest(r *http.Request) (
	req *CreateOrganizationAliasReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request CreateOrganizationAliasReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "aliasName",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.AliasName = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"aliasName\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeEditTalkSessionRequest(r *http.Request) (
	req *EditTalkSessionReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "application/json":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		buf, err := io.ReadAll(r.Body)
		if err != nil {
			return req, close, err
		}

		if len(buf) == 0 {
			return req, close, validate.ErrBodyRequired
		}

		d := jx.DecodeBytes(buf)

		var request EditTalkSessionReq
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			if err := d.Skip(); err != io.EOF {
				return errors.New("unexpected trailing data")
			}
			return nil
		}(); err != nil {
			err = &ogenerrors.DecodeBodyError{
				ContentType: ct,
				Body:        buf,
				Err:         err,
			}
			return req, close, err
		}
		if err := func() error {
			if err := request.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, close, errors.Wrap(err, "validate")
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeEditTimeLineRequest(r *http.Request) (
	req *EditTimeLineReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request EditTimeLineReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "content",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Content.Reset()
						if err := request.Content.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"content\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "status",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Status.Reset()
						if err := request.Status.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"status\"")
				}
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeEstablishOrganizationRequest(r *http.Request) (
	req *EstablishOrganizationReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request EstablishOrganizationReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Name = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"name\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "code",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Code = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"code\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "orgType",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					request.OrgType = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"orgType\"")
				}
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.OrgType)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeEstablishUserRequest(r *http.Request) (
	req *EstablishUserReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request EstablishUserReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "displayName",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.DisplayName = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"displayName\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "displayID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.DisplayID = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"displayID\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "dateOfBirth",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotDateOfBirthVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotDateOfBirthVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.DateOfBirth.SetTo(requestDotDateOfBirthVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"dateOfBirth\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "gender",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Gender.Reset()
						if err := request.Gender.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"gender\"")
				}
				if err := func() error {
					if value, ok := request.Gender.Get(); ok {
						if err := func() error {
							if err := value.Validate(); err != nil {
								return err
							}
							return nil
						}(); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "prefecture",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotPrefectureVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotPrefectureVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Prefecture.SetTo(requestDotPrefectureVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"prefecture\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "city",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.City.Reset()
						if err := request.City.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"city\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "email",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Email.Reset()
						if err := request.Email.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"email\"")
				}
			}
		}
		{
			if err := func() error {
				files, ok := r.MultipartForm.File["icon"]
				if !ok || len(files) < 1 {
					return nil
				}
				fh := files[0]

				f, err := fh.Open()
				if err != nil {
					return errors.Wrap(err, "open")
				}
				closers = append(closers, f.Close)
				request.Icon.SetTo(ht.MultipartFile{
					Name:   fh.Filename,
					File:   f,
					Size:   fh.Size,
					Header: fh.Header,
				})
				return nil
			}(); err != nil {
				return req, close, errors.Wrap(err, "decode \"icon\"")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeInitiateTalkSessionRequest(r *http.Request) (
	req *InitiateTalkSessionReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request InitiateTalkSessionReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "theme",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Theme = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"theme\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "scheduledEndTime",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					request.ScheduledEndTime = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"scheduledEndTime\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "latitude",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Latitude.Reset()
						if err := request.Latitude.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"latitude\"")
				}
				if err := func() error {
					if value, ok := request.Latitude.Get(); ok {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(value)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "longitude",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Longitude.Reset()
						if err := request.Longitude.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"longitude\"")
				}
				if err := func() error {
					if value, ok := request.Longitude.Get(); ok {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(value)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "city",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.City.Reset()
						if err := request.City.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"city\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "prefecture",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Prefecture.Reset()
						if err := request.Prefecture.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"prefecture\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "description",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Description.Reset()
						if err := request.Description.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"description\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "thumbnailURL",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.ThumbnailURL.Reset()
						if err := request.ThumbnailURL.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"thumbnailURL\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "restrictions",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Restrictions = make([]string, 0)
						if err := d.Arr(func(d *jx.Decoder) error {
							var elem string
							v, err := d.Str()
							elem = string(v)
							if err != nil {
								return err
							}
							request.Restrictions = append(request.Restrictions, elem)
							return nil
						}); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"restrictions\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "organizationAliasID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.OrganizationAliasID.Reset()
						if err := request.OrganizationAliasID.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"organizationAliasID\"")
				}
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeInviteOrganizationRequest(r *http.Request) (
	req *InviteOrganizationReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request InviteOrganizationReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "email",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Email = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"email\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "role",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					request.Role = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"role\"")
				}
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Role)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeInviteOrganizationForUserRequest(r *http.Request) (
	req *InviteOrganizationForUserReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request InviteOrganizationForUserReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "displayID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.DisplayID = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"displayID\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "role",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					request.Role = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"role\"")
				}
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Role)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeManageRegenerateManageRequest(r *http.Request) (
	req *RegenerateRequest,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "application/x-www-form-urlencoded":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		form, err := ht.ParseForm(r)
		if err != nil {
			return req, close, errors.Wrap(err, "parse form")
		}

		var request RegenerateRequest
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "type",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Type = RegenerateRequestType(c)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"type\"")
				}
				if err := func() error {
					if err := request.Type.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePasswordLoginRequest(r *http.Request) (
	req *PasswordLoginReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PasswordLoginReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "idOrEmail",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.IdOrEmail = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"idOrEmail\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "password",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Password = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"password\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePasswordRegisterRequest(r *http.Request) (
	req *PasswordRegisterReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PasswordRegisterReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "id",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.ID = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"id\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "password",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Password = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"password\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "email",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Email = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"email\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePolicyConsentRequest(r *http.Request) (
	req *PolicyConsentReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PolicyConsentReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "policyVersion",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.PolicyVersion = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"policyVersion\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePostConclusionRequest(r *http.Request) (
	req *PostConclusionReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PostConclusionReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "content",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Content = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"content\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePostImageRequest(r *http.Request) (
	req *PostImageReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PostImageReq
		{
			if err := func() error {
				files, ok := r.MultipartForm.File["image"]
				if !ok || len(files) < 1 {
					return validate.ErrFieldRequired
				}
				fh := files[0]

				f, err := fh.Open()
				if err != nil {
					return errors.Wrap(err, "open")
				}
				closers = append(closers, f.Close)
				request.Image = ht.MultipartFile{
					Name:   fh.Filename,
					File:   f,
					Size:   fh.Size,
					Header: fh.Header,
				}
				return nil
			}(); err != nil {
				return req, close, errors.Wrap(err, "decode \"image\"")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePostOpinionPost2Request(r *http.Request) (
	req *PostOpinionPost2Req,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PostOpinionPost2Req
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "talkSessionID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.TalkSessionID.Reset()
						if err := request.TalkSessionID.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"talkSessionID\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "parentOpinionID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.ParentOpinionID.Reset()
						if err := request.ParentOpinionID.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"parentOpinionID\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "title",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Title.Reset()
						if err := request.Title.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"title\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "opinionContent",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.OpinionContent = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"opinionContent\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "referenceURL",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.ReferenceURL.Reset()
						if err := request.ReferenceURL.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"referenceURL\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "isSeed",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.IsSeed.Reset()
						if err := request.IsSeed.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"isSeed\"")
				}
			}
		}
		{
			if err := func() error {
				files, ok := r.MultipartForm.File["picture"]
				if !ok || len(files) < 1 {
					return nil
				}
				fh := files[0]

				f, err := fh.Open()
				if err != nil {
					return errors.Wrap(err, "open")
				}
				closers = append(closers, f.Close)
				request.Picture.SetTo(ht.MultipartFile{
					Name:   fh.Filename,
					File:   f,
					Size:   fh.Size,
					Header: fh.Header,
				})
				return nil
			}(); err != nil {
				return req, close, errors.Wrap(err, "decode \"picture\"")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodePostTimeLineItemRequest(r *http.Request) (
	req *PostTimeLineItemReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request PostTimeLineItemReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "content",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Content = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"content\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "status",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Status = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"status\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "parentActionItemID",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.ParentActionItemID.Reset()
						if err := request.ParentActionItemID.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"parentActionItemID\"")
				}
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeReportOpinionRequest(r *http.Request) (
	req *ReportOpinionReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request ReportOpinionReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "reason",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Reason.Reset()
						if err := request.Reason.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"reason\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "content",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Content.Reset()
						if err := request.Content.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"content\"")
				}
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeSolveOpinionReportRequest(r *http.Request) (
	req *SolveOpinionReportReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request SolveOpinionReportReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "action",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						if err := request.Action.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"action\"")
				}
				if err := func() error {
					if err := request.Action.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeToggleReportVisibilityManageRequest(r *http.Request) (
	req *ToggleReportVisibilityRequest,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "application/x-www-form-urlencoded":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		form, err := ht.ParseForm(r)
		if err != nil {
			return req, close, errors.Wrap(err, "parse form")
		}

		var request ToggleReportVisibilityRequest
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "hidden",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					request.Hidden = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"hidden\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeUpdateUserProfileRequest(r *http.Request) (
	req *UpdateUserProfileReq,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request UpdateUserProfileReq
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "displayName",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.DisplayName.Reset()
						if err := request.DisplayName.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"displayName\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "deleteIcon",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.DeleteIcon.Reset()
						if err := request.DeleteIcon.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"deleteIcon\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "dateOfBirth",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotDateOfBirthVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotDateOfBirthVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.DateOfBirth.SetTo(requestDotDateOfBirthVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"dateOfBirth\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "gender",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Gender.Reset()
						if err := request.Gender.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"gender\"")
				}
				if err := func() error {
					if value, ok := request.Gender.Get(); ok {
						if err := func() error {
							if err := value.Validate(); err != nil {
								return err
							}
							return nil
						}(); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "city",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.City.Reset()
						if err := request.City.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"city\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "prefecture",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Prefecture.Reset()
						if err := request.Prefecture.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"prefecture\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "email",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						request.Email.Reset()
						if err := request.Email.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"email\"")
				}
			}
		}
		{
			if err := func() error {
				files, ok := r.MultipartForm.File["icon"]
				if !ok || len(files) < 1 {
					return nil
				}
				fh := files[0]

				f, err := fh.Open()
				if err != nil {
					return errors.Wrap(err, "open")
				}
				closers = append(closers, f.Close)
				request.Icon.SetTo(ht.MultipartFile{
					Name:   fh.Filename,
					File:   f,
					Size:   fh.Size,
					Header: fh.Header,
				})
				return nil
			}(); err != nil {
				return req, close, errors.Wrap(err, "decode \"icon\"")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeVote2Request(r *http.Request) (
	req *Vote2Req,
	close func() error,
	rerr error,
) {
	var closers []func() error
	close = func() error {
		var merr error
		// Close in reverse order, to match defer behavior.
		for i := len(closers) - 1; i >= 0; i-- {
			c := closers[i]
			merr = multierr.Append(merr, c())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch {
	case ct == "multipart/form-data":
		if r.ContentLength == 0 {
			return req, close, validate.ErrBodyRequired
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		// Remove all temporary files created by ParseMultipartForm when the request is done.
		//
		// Notice that the closers are called in reverse order, to match defer behavior, so
		// any opened file will be closed before RemoveAll call.
		closers = append(closers, r.MultipartForm.RemoveAll)
		// Form values may be unused.
		form := url.Values(r.MultipartForm.Value)
		_ = form

		var request Vote2Req
		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "voteStatus",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}
			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}
					if err := func(d *jx.Decoder) error {
						if err := request.VoteStatus.Decode(d); err != nil {
							return err
						}
						return nil
					}(jx.DecodeStr(val)); err != nil {
						return err
					}
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"voteStatus\"")
				}
				if err := func() error {
					if value, ok := request.VoteStatus.Get(); ok {
						if err := func() error {
							if err := value.Validate(); err != nil {
								return err
							}
							return nil
						}(); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return &request, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}
