// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: talk_session_result.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createActionItem = `-- name: CreateActionItem :exec
INSERT INTO action_items (
    action_item_id,
    talk_session_id,
    parent_action_item_id,
    content,
    status
) VALUES ($1, $2, $3, $4, $5)
`

type CreateActionItemParams struct {
	ActionItemID       uuid.UUID
	TalkSessionID      uuid.UUID
	ParentActionItemID uuid.NullUUID
	Content            string
	Status             string
}

func (q *Queries) CreateActionItem(ctx context.Context, arg CreateActionItemParams) error {
	_, err := q.db.ExecContext(ctx, createActionItem,
		arg.ActionItemID,
		arg.TalkSessionID,
		arg.ParentActionItemID,
		arg.Content,
		arg.Status,
	)
	return err
}

const createTalkSessionConclusion = `-- name: CreateTalkSessionConclusion :exec
INSERT INTO talk_session_conclusions (
    talk_session_id,
    content,
    created_by
) VALUES ($1, $2, $3)
`

type CreateTalkSessionConclusionParams struct {
	TalkSessionID uuid.UUID
	Content       string
	CreatedBy     uuid.UUID
}

func (q *Queries) CreateTalkSessionConclusion(ctx context.Context, arg CreateTalkSessionConclusionParams) error {
	_, err := q.db.ExecContext(ctx, createTalkSessionConclusion, arg.TalkSessionID, arg.Content, arg.CreatedBy)
	return err
}

const getActionItemsByTalkSessionID = `-- name: GetActionItemsByTalkSessionID :many
WITH RECURSIVE action_item_tree AS (
    SELECT
        action_items.action_item_id,
        action_items.talk_session_id,
        action_items.parent_action_item_id,
        action_items.content,
        action_items.status,
        action_items.created_at,
        action_items.updated_at,
        1 AS depth
    FROM action_items
    WHERE action_items.talk_session_id = $1
    AND action_items.parent_action_item_id IS NULL

    UNION ALL

    SELECT
        action_items.action_item_id,
        action_items.talk_session_id,
        action_items.parent_action_item_id,
        action_items.content,
        action_items.status,
        action_items.created_at,
        action_items.updated_at,
        action_item_tree.depth + 1
    FROM action_items
    JOIN action_item_tree
        ON action_items.parent_action_item_id = action_item_tree.action_item_id
)
SELECT
    action_item_tree.action_item_id,
    action_item_tree.talk_session_id,
    action_item_tree.parent_action_item_id,
    action_item_tree.content,
    action_item_tree.status,
    action_item_tree.created_at,
    action_item_tree.updated_at,
    action_item_tree.depth,
    users.display_name AS display_name,
    users.display_id AS display,
    users.icon_url AS icon_url
FROM action_item_tree
LEFT JOIN users
    ON action_item_tree.created_by = users.user_id
ORDER BY action_item_tree.created_at ASC
`

type GetActionItemsByTalkSessionIDRow struct {
	ActionItemID       uuid.UUID
	TalkSessionID      uuid.UUID
	ParentActionItemID uuid.NullUUID
	Content            string
	Status             string
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Depth              int32
	DisplayName        sql.NullString
	Display            sql.NullString
	IconUrl            sql.NullString
}

// トークセッションに紐づくアクションアイテムを再起的に取得
func (q *Queries) GetActionItemsByTalkSessionID(ctx context.Context, talkSessionID uuid.UUID) ([]GetActionItemsByTalkSessionIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionItemsByTalkSessionID, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActionItemsByTalkSessionIDRow
	for rows.Next() {
		var i GetActionItemsByTalkSessionIDRow
		if err := rows.Scan(
			&i.ActionItemID,
			&i.TalkSessionID,
			&i.ParentActionItemID,
			&i.Content,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Depth,
			&i.DisplayName,
			&i.Display,
			&i.IconUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTalkSessionConclusionByID = `-- name: GetTalkSessionConclusionByID :one
SELECT
    talk_session_conclusions.talk_session_id,
    talk_session_conclusions.content,
    talk_session_conclusions.created_by,
    talk_session_conclusions.created_at,
    talk_session_conclusions.updated_at,
    users.user_id AS user_id,
    users.display_name AS display_name,
    users.display_id AS display_id,
    users.icon_url AS icon_url
FROM talk_session_conclusions
LEFT JOIN users
    ON talk_session_conclusions.created_by = users.user_id
WHERE talk_session_id = $1
`

type GetTalkSessionConclusionByIDRow struct {
	TalkSessionID uuid.UUID
	Content       string
	CreatedBy     uuid.UUID
	CreatedAt     time.Time
	UpdatedAt     time.Time
	UserID        uuid.NullUUID
	DisplayName   sql.NullString
	DisplayID     sql.NullString
	IconUrl       sql.NullString
}

func (q *Queries) GetTalkSessionConclusionByID(ctx context.Context, talkSessionID uuid.UUID) (GetTalkSessionConclusionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTalkSessionConclusionByID, talkSessionID)
	var i GetTalkSessionConclusionByIDRow
	err := row.Scan(
		&i.TalkSessionID,
		&i.Content,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.DisplayName,
		&i.DisplayID,
		&i.IconUrl,
	)
	return i, err
}

const updateActionItem = `-- name: UpdateActionItem :exec
UPDATE action_items
SET
    content = $2,
    status = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE action_item_id = $1
`

type UpdateActionItemParams struct {
	ActionItemID uuid.UUID
	Content      string
	Status       string
}

func (q *Queries) UpdateActionItem(ctx context.Context, arg UpdateActionItemParams) error {
	_, err := q.db.ExecContext(ctx, updateActionItem, arg.ActionItemID, arg.Content, arg.Status)
	return err
}

const updateTalkSessionConclusion = `-- name: UpdateTalkSessionConclusion :exec
UPDATE talk_session_conclusions
SET
    content = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE talk_session_id = $1
`

type UpdateTalkSessionConclusionParams struct {
	TalkSessionID uuid.UUID
	Content       string
}

func (q *Queries) UpdateTalkSessionConclusion(ctx context.Context, arg UpdateTalkSessionConclusionParams) error {
	_, err := q.db.ExecContext(ctx, updateTalkSessionConclusion, arg.TalkSessionID, arg.Content)
	return err
}
