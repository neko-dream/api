// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_stats.sql

package model

import (
	"context"
	"time"
)

const getDailyUserStats = `-- name: GetDailyUserStats :many
WITH user_activity AS (
    SELECT DISTINCT
        users.user_id,
        DATE_TRUNC('day', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
    AND users.display_id IS NOT NULL
)
SELECT
    activity_date::date,
    COUNT(*) as total_users,
    SUM(has_voted) as users_with_votes,
    SUM(has_posted) as users_with_posts,
    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
FROM user_activity
GROUP BY activity_date
ORDER BY activity_date DESC
LIMIT $1 OFFSET $2
`

type GetDailyUserStatsParams struct {
	Limit  int32
	Offset int32
}

type GetDailyUserStatsRow struct {
	ActivityDate   time.Time
	TotalUsers     int64
	UsersWithVotes int64
	UsersWithPosts int64
	ActiveUsers    int64
}

// GetDailyUserStats
//
//	WITH user_activity AS (
//	    SELECT DISTINCT
//	        users.user_id,
//	        DATE_TRUNC('day', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    activity_date::date,
//	    COUNT(*) as total_users,
//	    SUM(has_voted) as users_with_votes,
//	    SUM(has_posted) as users_with_posts,
//	    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
//	FROM user_activity
//	GROUP BY activity_date
//	ORDER BY activity_date DESC
//	LIMIT $1 OFFSET $2
func (q *Queries) GetDailyUserStats(ctx context.Context, arg GetDailyUserStatsParams) ([]GetDailyUserStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyUserStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyUserStatsRow
	for rows.Next() {
		var i GetDailyUserStatsRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.TotalUsers,
			&i.UsersWithVotes,
			&i.UsersWithPosts,
			&i.ActiveUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
WITH user_activity AS (
    SELECT DISTINCT users.user_id,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND users.display_id IS NOT NULL
)
SELECT
    COUNT(*) as total_users,
    SUM(has_voted) as users_with_votes,
    SUM(has_posted) as users_with_posts,
    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
FROM user_activity
`

type GetUserStatsRow struct {
	TotalUsers     int64
	UsersWithVotes int64
	UsersWithPosts int64
	ActiveUsers    int64
}

// GetUserStats
//
//	WITH user_activity AS (
//	    SELECT DISTINCT users.user_id,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    COUNT(*) as total_users,
//	    SUM(has_voted) as users_with_votes,
//	    SUM(has_posted) as users_with_posts,
//	    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
//	FROM user_activity
func (q *Queries) GetUserStats(ctx context.Context) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.UsersWithVotes,
		&i.UsersWithPosts,
		&i.ActiveUsers,
	)
	return i, err
}

const getWeeklyUserStats = `-- name: GetWeeklyUserStats :many
WITH user_activity AS (
    SELECT DISTINCT
        users.user_id,
        DATE_TRUNC('week', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
    AND users.display_id IS NOT NULL
)
SELECT
    activity_date::date,
    COUNT(*) as total_users,
    SUM(has_voted) as users_with_votes,
    SUM(has_posted) as users_with_posts,
    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
FROM user_activity
GROUP BY activity_date
ORDER BY activity_date DESC
LIMIT $1 OFFSET $2
`

type GetWeeklyUserStatsParams struct {
	Limit  int32
	Offset int32
}

type GetWeeklyUserStatsRow struct {
	ActivityDate   time.Time
	TotalUsers     int64
	UsersWithVotes int64
	UsersWithPosts int64
	ActiveUsers    int64
}

// GetWeeklyUserStats
//
//	WITH user_activity AS (
//	    SELECT DISTINCT
//	        users.user_id,
//	        DATE_TRUNC('week', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    activity_date::date,
//	    COUNT(*) as total_users,
//	    SUM(has_voted) as users_with_votes,
//	    SUM(has_posted) as users_with_posts,
//	    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
//	FROM user_activity
//	GROUP BY activity_date
//	ORDER BY activity_date DESC
//	LIMIT $1 OFFSET $2
func (q *Queries) GetWeeklyUserStats(ctx context.Context, arg GetWeeklyUserStatsParams) ([]GetWeeklyUserStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyUserStats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyUserStatsRow
	for rows.Next() {
		var i GetWeeklyUserStatsRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.TotalUsers,
			&i.UsersWithVotes,
			&i.UsersWithPosts,
			&i.ActiveUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
