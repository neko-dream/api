// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_stats.sql

package model

import (
	"context"
	"time"
)

const getDailyUserStats = `-- name: GetDailyUserStats :many
WITH date_range AS (
    SELECT generate_series(
        CURRENT_DATE - (($1::integer + $2::integer - 1) * INTERVAL '1 day'),
        CURRENT_DATE - ($1::integer * INTERVAL '1 day'),
        INTERVAL '1 day'
    )::date as activity_date
),
user_activity AS (
    SELECT DISTINCT
        users.user_id,
        DATE_TRUNC('day', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
    AND users.display_id IS NOT NULL
)
SELECT
    date_range.activity_date,
    COALESCE(COUNT(user_activity.user_id), 0)::integer as total_users,
    COALESCE(SUM(has_voted), 0) as users_with_votes,
    COALESCE(SUM(has_posted), 0) as users_with_posts,
    COALESCE(SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END), 0)::integer as active_users
FROM date_range
LEFT JOIN user_activity ON date_range.activity_date = user_activity.activity_date::date
GROUP BY date_range.activity_date
ORDER BY date_range.activity_date DESC
`

type GetDailyUserStatsParams struct {
	Offset int32
	Limit  int32
}

type GetDailyUserStatsRow struct {
	ActivityDate   time.Time
	TotalUsers     int32
	UsersWithVotes interface{}
	UsersWithPosts interface{}
	ActiveUsers    int32
}

// GetDailyUserStats
//
//	WITH date_range AS (
//	    SELECT generate_series(
//	        CURRENT_DATE - (($1::integer + $2::integer - 1) * INTERVAL '1 day'),
//	        CURRENT_DATE - ($1::integer * INTERVAL '1 day'),
//	        INTERVAL '1 day'
//	    )::date as activity_date
//	),
//	user_activity AS (
//	    SELECT DISTINCT
//	        users.user_id,
//	        DATE_TRUNC('day', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    date_range.activity_date,
//	    COALESCE(COUNT(user_activity.user_id), 0)::integer as total_users,
//	    COALESCE(SUM(has_voted), 0) as users_with_votes,
//	    COALESCE(SUM(has_posted), 0) as users_with_posts,
//	    COALESCE(SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END), 0)::integer as active_users
//	FROM date_range
//	LEFT JOIN user_activity ON date_range.activity_date = user_activity.activity_date::date
//	GROUP BY date_range.activity_date
//	ORDER BY date_range.activity_date DESC
func (q *Queries) GetDailyUserStats(ctx context.Context, arg GetDailyUserStatsParams) ([]GetDailyUserStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyUserStats, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyUserStatsRow
	for rows.Next() {
		var i GetDailyUserStatsRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.TotalUsers,
			&i.UsersWithVotes,
			&i.UsersWithPosts,
			&i.ActiveUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
WITH user_activity AS (
    SELECT DISTINCT users.user_id,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND users.display_id IS NOT NULL
)
SELECT
    COUNT(*) as total_users,
    SUM(has_voted) as users_with_votes,
    SUM(has_posted) as users_with_posts,
    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
FROM user_activity
`

type GetUserStatsRow struct {
	TotalUsers     int64
	UsersWithVotes int64
	UsersWithPosts int64
	ActiveUsers    int64
}

// GetUserStats
//
//	WITH user_activity AS (
//	    SELECT DISTINCT users.user_id,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    COUNT(*) as total_users,
//	    SUM(has_voted) as users_with_votes,
//	    SUM(has_posted) as users_with_posts,
//	    SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END) as active_users
//	FROM user_activity
func (q *Queries) GetUserStats(ctx context.Context) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.UsersWithVotes,
		&i.UsersWithPosts,
		&i.ActiveUsers,
	)
	return i, err
}

const getWeeklyUserStats = `-- name: GetWeeklyUserStats :many
WITH date_range AS (
    SELECT generate_series(
        DATE_TRUNC('week', CURRENT_DATE - (($1::integer + $2::integer - 1) * INTERVAL '1 week')),
        DATE_TRUNC('week', CURRENT_DATE - ($1::integer * INTERVAL '1 week')),
        INTERVAL '1 week'
    )::date as activity_date
),
user_activity AS (
    SELECT DISTINCT
        users.user_id,
        DATE_TRUNC('week', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
    FROM users
    LEFT JOIN votes ON users.user_id = votes.user_id
    LEFT JOIN opinions ON users.user_id = opinions.user_id
    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
    AND users.display_id IS NOT NULL
)
SELECT
    date_range.activity_date,
    COALESCE(COUNT(user_activity.user_id), 0)::integer as total_users,
    COALESCE(SUM(has_voted), 0) as users_with_votes,
    COALESCE(SUM(has_posted), 0) as users_with_posts,
    COALESCE(SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END), 0)::integer as active_users
FROM date_range
LEFT JOIN user_activity ON date_range.activity_date = user_activity.activity_date::date
GROUP BY date_range.activity_date
ORDER BY date_range.activity_date DESC
`

type GetWeeklyUserStatsParams struct {
	Offset int32
	Limit  int32
}

type GetWeeklyUserStatsRow struct {
	ActivityDate   time.Time
	TotalUsers     int32
	UsersWithVotes interface{}
	UsersWithPosts interface{}
	ActiveUsers    int32
}

// GetWeeklyUserStats
//
//	WITH date_range AS (
//	    SELECT generate_series(
//	        DATE_TRUNC('week', CURRENT_DATE - (($1::integer + $2::integer - 1) * INTERVAL '1 week')),
//	        DATE_TRUNC('week', CURRENT_DATE - ($1::integer * INTERVAL '1 week')),
//	        INTERVAL '1 week'
//	    )::date as activity_date
//	),
//	user_activity AS (
//	    SELECT DISTINCT
//	        users.user_id,
//	        DATE_TRUNC('week', COALESCE(votes.created_at, opinions.created_at)) as activity_date,
//	        CASE WHEN votes.user_id IS NOT NULL THEN 1 ELSE 0 END as has_voted,
//	        CASE WHEN opinions.user_id IS NOT NULL THEN 1 ELSE 0 END as has_posted
//	    FROM users
//	    LEFT JOIN votes ON users.user_id = votes.user_id
//	    LEFT JOIN opinions ON users.user_id = opinions.user_id
//	    WHERE users.user_id != '00000000-0000-0000-0000-000000000001'::uuid
//	    AND COALESCE(votes.created_at, opinions.created_at) IS NOT NULL
//	    AND users.display_id IS NOT NULL
//	)
//	SELECT
//	    date_range.activity_date,
//	    COALESCE(COUNT(user_activity.user_id), 0)::integer as total_users,
//	    COALESCE(SUM(has_voted), 0) as users_with_votes,
//	    COALESCE(SUM(has_posted), 0) as users_with_posts,
//	    COALESCE(SUM(CASE WHEN has_voted = 1 OR has_posted = 1 THEN 1 ELSE 0 END), 0)::integer as active_users
//	FROM date_range
//	LEFT JOIN user_activity ON date_range.activity_date = user_activity.activity_date::date
//	GROUP BY date_range.activity_date
//	ORDER BY date_range.activity_date DESC
func (q *Queries) GetWeeklyUserStats(ctx context.Context, arg GetWeeklyUserStatsParams) ([]GetWeeklyUserStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyUserStats, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyUserStatsRow
	for rows.Next() {
		var i GetWeeklyUserStatsRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.TotalUsers,
			&i.UsersWithVotes,
			&i.UsersWithPosts,
			&i.ActiveUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
