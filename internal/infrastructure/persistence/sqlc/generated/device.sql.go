// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: device.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createDevice = `-- name: CreateDevice :one
INSERT INTO devices (
    device_id,
    user_id,
    device_token,
    platform,
    device_name,
    app_version,
    os_version,
    enabled,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
`

type CreateDeviceParams struct {
	DeviceID    uuid.UUID
	UserID      uuid.UUID
	DeviceToken string
	Platform    string
	DeviceName  sql.NullString
	AppVersion  sql.NullString
	OsVersion   sql.NullString
	Enabled     bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// CreateDevice
//
//	INSERT INTO devices (
//	    device_id,
//	    user_id,
//	    device_token,
//	    platform,
//	    device_name,
//	    app_version,
//	    os_version,
//	    enabled,
//	    created_at,
//	    updated_at
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10
//	) RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
func (q *Queries) CreateDevice(ctx context.Context, arg CreateDeviceParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, createDevice,
		arg.DeviceID,
		arg.UserID,
		arg.DeviceToken,
		arg.Platform,
		arg.DeviceName,
		arg.AppVersion,
		arg.OsVersion,
		arg.Enabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Device
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceName,
		&i.AppVersion,
		&i.OsVersion,
		&i.LastActiveAt,
	)
	return i, err
}

const deleteDevice = `-- name: DeleteDevice :exec
DELETE FROM devices
WHERE device_id = $1
`

// DeleteDevice
//
//	DELETE FROM devices
//	WHERE device_id = $1
func (q *Queries) DeleteDevice(ctx context.Context, deviceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDevice, deviceID)
	return err
}

const deleteDeviceByUserID = `-- name: DeleteDeviceByUserID :exec
DELETE FROM devices
WHERE device_id = $1 AND user_id = $2
`

type DeleteDeviceByUserIDParams struct {
	DeviceID uuid.UUID
	UserID   uuid.UUID
}

// DeleteDeviceByUserID
//
//	DELETE FROM devices
//	WHERE device_id = $1 AND user_id = $2
func (q *Queries) DeleteDeviceByUserID(ctx context.Context, arg DeleteDeviceByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteDeviceByUserID, arg.DeviceID, arg.UserID)
	return err
}

const deleteDevicesByUserID = `-- name: DeleteDevicesByUserID :exec
DELETE FROM devices
WHERE user_id = $1
`

// DeleteDevicesByUserID
//
//	DELETE FROM devices
//	WHERE user_id = $1
func (q *Queries) DeleteDevicesByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDevicesByUserID, userID)
	return err
}

const existsByDeviceTokenAndPlatform = `-- name: ExistsByDeviceTokenAndPlatform :one
SELECT EXISTS (
    SELECT 1 FROM devices
    WHERE device_token = $1 AND platform = $2
) AS exists
`

type ExistsByDeviceTokenAndPlatformParams struct {
	DeviceToken string
	Platform    string
}

// ExistsByDeviceTokenAndPlatform
//
//	SELECT EXISTS (
//	    SELECT 1 FROM devices
//	    WHERE device_token = $1 AND platform = $2
//	) AS exists
func (q *Queries) ExistsByDeviceTokenAndPlatform(ctx context.Context, arg ExistsByDeviceTokenAndPlatformParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsByDeviceTokenAndPlatform, arg.DeviceToken, arg.Platform)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getActiveDevicesByUserID = `-- name: GetActiveDevicesByUserID :many
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE user_id = $1 AND enabled = true
ORDER BY created_at DESC
`

// GetActiveDevicesByUserID
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE user_id = $1 AND enabled = true
//	ORDER BY created_at DESC
func (q *Queries) GetActiveDevicesByUserID(ctx context.Context, userID uuid.UUID) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, getActiveDevicesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.DeviceID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceName,
			&i.AppVersion,
			&i.OsVersion,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveDevicesByUserIDs = `-- name: GetActiveDevicesByUserIDs :many
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE user_id = ANY($1::uuid[]) AND enabled = true
ORDER BY user_id, created_at DESC
`

// GetActiveDevicesByUserIDs
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE user_id = ANY($1::uuid[]) AND enabled = true
//	ORDER BY user_id, created_at DESC
func (q *Queries) GetActiveDevicesByUserIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, getActiveDevicesByUserIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.DeviceID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceName,
			&i.AppVersion,
			&i.OsVersion,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveDevices = `-- name: GetAllActiveDevices :many
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE enabled = true
ORDER BY user_id, created_at DESC
`

// GetAllActiveDevices
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE enabled = true
//	ORDER BY user_id, created_at DESC
func (q *Queries) GetAllActiveDevices(ctx context.Context) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.DeviceID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceName,
			&i.AppVersion,
			&i.OsVersion,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceByID = `-- name: GetDeviceByID :one
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE device_id = $1
`

// GetDeviceByID
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE device_id = $1
func (q *Queries) GetDeviceByID(ctx context.Context, deviceID uuid.UUID) (Device, error) {
	row := q.db.QueryRowContext(ctx, getDeviceByID, deviceID)
	var i Device
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceName,
		&i.AppVersion,
		&i.OsVersion,
		&i.LastActiveAt,
	)
	return i, err
}

const getDeviceByToken = `-- name: GetDeviceByToken :one
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE device_token = $1
`

// GetDeviceByToken
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE device_token = $1
func (q *Queries) GetDeviceByToken(ctx context.Context, deviceToken string) (Device, error) {
	row := q.db.QueryRowContext(ctx, getDeviceByToken, deviceToken)
	var i Device
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceName,
		&i.AppVersion,
		&i.OsVersion,
		&i.LastActiveAt,
	)
	return i, err
}

const getDevicesByUserID = `-- name: GetDevicesByUserID :many
SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
WHERE user_id = $1
ORDER BY created_at DESC
`

// GetDevicesByUserID
//
//	SELECT device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at FROM devices
//	WHERE user_id = $1
//	ORDER BY created_at DESC
func (q *Queries) GetDevicesByUserID(ctx context.Context, userID uuid.UUID) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, getDevicesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.DeviceID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceName,
			&i.AppVersion,
			&i.OsVersion,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateDevice = `-- name: InvalidateDevice :exec
UPDATE devices SET
    enabled = false,
    updated_at = CURRENT_TIMESTAMP
WHERE device_id = $1
`

// InvalidateDevice
//
//	UPDATE devices SET
//	    enabled = false,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE device_id = $1
func (q *Queries) InvalidateDevice(ctx context.Context, deviceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, invalidateDevice, deviceID)
	return err
}

const invalidateDeviceByToken = `-- name: InvalidateDeviceByToken :exec
UPDATE devices SET
    enabled = false,
    updated_at = CURRENT_TIMESTAMP
WHERE device_token = $1 AND platform = $2
`

type InvalidateDeviceByTokenParams struct {
	DeviceToken string
	Platform    string
}

// InvalidateDeviceByToken
//
//	UPDATE devices SET
//	    enabled = false,
//	    updated_at = CURRENT_TIMESTAMP
//	WHERE device_token = $1 AND platform = $2
func (q *Queries) InvalidateDeviceByToken(ctx context.Context, arg InvalidateDeviceByTokenParams) error {
	_, err := q.db.ExecContext(ctx, invalidateDeviceByToken, arg.DeviceToken, arg.Platform)
	return err
}

const updateDevice = `-- name: UpdateDevice :one
UPDATE devices SET
    device_token = $2,
    platform = $3,
    device_name = COALESCE($4, device_name),
    app_version = COALESCE($5, app_version),
    os_version = COALESCE($6, os_version),
    enabled = $7,
    last_active_at = CURRENT_TIMESTAMP,
    updated_at = $8
WHERE device_id = $1
RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
`

type UpdateDeviceParams struct {
	DeviceID    uuid.UUID
	DeviceToken string
	Platform    string
	DeviceName  sql.NullString
	AppVersion  sql.NullString
	OsVersion   sql.NullString
	Enabled     bool
	UpdatedAt   time.Time
}

// UpdateDevice
//
//	UPDATE devices SET
//	    device_token = $2,
//	    platform = $3,
//	    device_name = COALESCE($4, device_name),
//	    app_version = COALESCE($5, app_version),
//	    os_version = COALESCE($6, os_version),
//	    enabled = $7,
//	    last_active_at = CURRENT_TIMESTAMP,
//	    updated_at = $8
//	WHERE device_id = $1
//	RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
func (q *Queries) UpdateDevice(ctx context.Context, arg UpdateDeviceParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, updateDevice,
		arg.DeviceID,
		arg.DeviceToken,
		arg.Platform,
		arg.DeviceName,
		arg.AppVersion,
		arg.OsVersion,
		arg.Enabled,
		arg.UpdatedAt,
	)
	var i Device
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceName,
		&i.AppVersion,
		&i.OsVersion,
		&i.LastActiveAt,
	)
	return i, err
}

const updateDeviceActivity = `-- name: UpdateDeviceActivity :exec
UPDATE devices SET
    last_active_at = CURRENT_TIMESTAMP
WHERE device_id = $1
`

// UpdateDeviceActivity
//
//	UPDATE devices SET
//	    last_active_at = CURRENT_TIMESTAMP
//	WHERE device_id = $1
func (q *Queries) UpdateDeviceActivity(ctx context.Context, deviceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateDeviceActivity, deviceID)
	return err
}

const upsertDevice = `-- name: UpsertDevice :one
INSERT INTO devices (
    device_id,
    user_id,
    device_token,
    platform,
    device_name,
    app_version,
    os_version,
    enabled,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) ON CONFLICT (user_id, device_token, platform) DO UPDATE SET
    device_name = COALESCE(EXCLUDED.device_name, devices.device_name),
    app_version = COALESCE(EXCLUDED.app_version, devices.app_version),
    os_version = COALESCE(EXCLUDED.os_version, devices.os_version),
    enabled = EXCLUDED.enabled,
    last_active_at = CURRENT_TIMESTAMP,
    updated_at = EXCLUDED.updated_at
RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
`

type UpsertDeviceParams struct {
	DeviceID    uuid.UUID
	UserID      uuid.UUID
	DeviceToken string
	Platform    string
	DeviceName  sql.NullString
	AppVersion  sql.NullString
	OsVersion   sql.NullString
	Enabled     bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// UpsertDevice
//
//	INSERT INTO devices (
//	    device_id,
//	    user_id,
//	    device_token,
//	    platform,
//	    device_name,
//	    app_version,
//	    os_version,
//	    enabled,
//	    created_at,
//	    updated_at
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8,
//	    $9,
//	    $10
//	) ON CONFLICT (user_id, device_token, platform) DO UPDATE SET
//	    device_name = COALESCE(EXCLUDED.device_name, devices.device_name),
//	    app_version = COALESCE(EXCLUDED.app_version, devices.app_version),
//	    os_version = COALESCE(EXCLUDED.os_version, devices.os_version),
//	    enabled = EXCLUDED.enabled,
//	    last_active_at = CURRENT_TIMESTAMP,
//	    updated_at = EXCLUDED.updated_at
//	RETURNING device_id, user_id, device_token, platform, enabled, created_at, updated_at, device_name, app_version, os_version, last_active_at
func (q *Queries) UpsertDevice(ctx context.Context, arg UpsertDeviceParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, upsertDevice,
		arg.DeviceID,
		arg.UserID,
		arg.DeviceToken,
		arg.Platform,
		arg.DeviceName,
		arg.AppVersion,
		arg.OsVersion,
		arg.Enabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Device
	err := row.Scan(
		&i.DeviceID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceName,
		&i.AppVersion,
		&i.OsVersion,
		&i.LastActiveAt,
	)
	return i, err
}
