// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: domain_events.sql

package model

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createDomainEvent = `-- name: CreateDomainEvent :one
INSERT INTO domain_events (
    id,
    event_type,
    event_data,
    aggregate_id,
    aggregate_type,
    status,
    occurred_at,
    retry_count
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
`

type CreateDomainEventParams struct {
	ID            uuid.UUID
	EventType     string
	EventData     json.RawMessage
	AggregateID   string
	AggregateType string
	Status        string
	OccurredAt    time.Time
	RetryCount    int32
}

// CreateDomainEvent
//
//	INSERT INTO domain_events (
//	    id,
//	    event_type,
//	    event_data,
//	    aggregate_id,
//	    aggregate_type,
//	    status,
//	    occurred_at,
//	    retry_count
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5,
//	    $6,
//	    $7,
//	    $8
//	) RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
func (q *Queries) CreateDomainEvent(ctx context.Context, arg CreateDomainEventParams) (DomainEvent, error) {
	row := q.db.QueryRowContext(ctx, createDomainEvent,
		arg.ID,
		arg.EventType,
		arg.EventData,
		arg.AggregateID,
		arg.AggregateType,
		arg.Status,
		arg.OccurredAt,
		arg.RetryCount,
	)
	var i DomainEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.EventData,
		&i.AggregateID,
		&i.AggregateType,
		&i.Status,
		&i.OccurredAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.FailureReason,
		&i.RetryCount,
	)
	return i, err
}

const getEventsByAggregateID = `-- name: GetEventsByAggregateID :many
SELECT id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count FROM domain_events
WHERE aggregate_id = $1
  AND aggregate_type = $2
ORDER BY occurred_at ASC
`

type GetEventsByAggregateIDParams struct {
	AggregateID   string
	AggregateType string
}

// GetEventsByAggregateID
//
//	SELECT id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count FROM domain_events
//	WHERE aggregate_id = $1
//	  AND aggregate_type = $2
//	ORDER BY occurred_at ASC
func (q *Queries) GetEventsByAggregateID(ctx context.Context, arg GetEventsByAggregateIDParams) ([]DomainEvent, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByAggregateID, arg.AggregateID, arg.AggregateType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DomainEvent
	for rows.Next() {
		var i DomainEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventData,
			&i.AggregateID,
			&i.AggregateType,
			&i.Status,
			&i.OccurredAt,
			&i.ProcessedAt,
			&i.FailedAt,
			&i.FailureReason,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedEvents = `-- name: GetUnprocessedEvents :many
SELECT id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count FROM domain_events
WHERE status IN ('pending', 'failed')
  AND (status != 'failed' OR retry_count < $1)
  AND ($2::text[] IS NULL OR event_type = ANY($2::text[]))
ORDER BY occurred_at ASC
LIMIT $3
FOR UPDATE SKIP LOCKED
`

type GetUnprocessedEventsParams struct {
	RetryCount int32
	Column2    []string
	Limit      int32
}

// GetUnprocessedEvents
//
//	SELECT id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count FROM domain_events
//	WHERE status IN ('pending', 'failed')
//	  AND (status != 'failed' OR retry_count < $1)
//	  AND ($2::text[] IS NULL OR event_type = ANY($2::text[]))
//	ORDER BY occurred_at ASC
//	LIMIT $3
//	FOR UPDATE SKIP LOCKED
func (q *Queries) GetUnprocessedEvents(ctx context.Context, arg GetUnprocessedEventsParams) ([]DomainEvent, error) {
	rows, err := q.db.QueryContext(ctx, getUnprocessedEvents, arg.RetryCount, pq.Array(arg.Column2), arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DomainEvent
	for rows.Next() {
		var i DomainEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventData,
			&i.AggregateID,
			&i.AggregateType,
			&i.Status,
			&i.OccurredAt,
			&i.ProcessedAt,
			&i.FailedAt,
			&i.FailureReason,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEventAsFailed = `-- name: MarkEventAsFailed :one
UPDATE domain_events
SET status = 'failed',
    failed_at = NOW(),
    failure_reason = $2,
    retry_count = retry_count + 1
WHERE id = $1
  AND status IN ('pending', 'processing')
RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
`

type MarkEventAsFailedParams struct {
	ID            uuid.UUID
	FailureReason sql.NullString
}

// MarkEventAsFailed
//
//	UPDATE domain_events
//	SET status = 'failed',
//	    failed_at = NOW(),
//	    failure_reason = $2,
//	    retry_count = retry_count + 1
//	WHERE id = $1
//	  AND status IN ('pending', 'processing')
//	RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
func (q *Queries) MarkEventAsFailed(ctx context.Context, arg MarkEventAsFailedParams) (DomainEvent, error) {
	row := q.db.QueryRowContext(ctx, markEventAsFailed, arg.ID, arg.FailureReason)
	var i DomainEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.EventData,
		&i.AggregateID,
		&i.AggregateType,
		&i.Status,
		&i.OccurredAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.FailureReason,
		&i.RetryCount,
	)
	return i, err
}

const markEventAsProcessed = `-- name: MarkEventAsProcessed :one
UPDATE domain_events
SET status = 'processed',
    processed_at = NOW()
WHERE id = $1
  AND status IN ('pending', 'processing', 'failed')
RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
`

// MarkEventAsProcessed
//
//	UPDATE domain_events
//	SET status = 'processed',
//	    processed_at = NOW()
//	WHERE id = $1
//	  AND status IN ('pending', 'processing', 'failed')
//	RETURNING id, event_type, event_data, aggregate_id, aggregate_type, status, occurred_at, processed_at, failed_at, failure_reason, retry_count
func (q *Queries) MarkEventAsProcessed(ctx context.Context, id uuid.UUID) (DomainEvent, error) {
	row := q.db.QueryRowContext(ctx, markEventAsProcessed, id)
	var i DomainEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.EventData,
		&i.AggregateID,
		&i.AggregateType,
		&i.Status,
		&i.OccurredAt,
		&i.ProcessedAt,
		&i.FailedAt,
		&i.FailureReason,
		&i.RetryCount,
	)
	return i, err
}
