// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: analysis.sql

package model

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addGeneratedImages = `-- name: AddGeneratedImages :exec
INSERT INTO talk_session_generated_images (talk_session_id, wordmap_url, tsnc_url) VALUES ($1, $2, $3)
ON CONFLICT (talk_session_id) DO UPDATE SET wordmap_url = $2, tsnc_url = $3, updated_at = NOW()
`

type AddGeneratedImagesParams struct {
	TalkSessionID uuid.UUID
	WordmapUrl    string
	TsncUrl       string
}

// AddGeneratedImages
//
//	INSERT INTO talk_session_generated_images (talk_session_id, wordmap_url, tsnc_url) VALUES ($1, $2, $3)
//	ON CONFLICT (talk_session_id) DO UPDATE SET wordmap_url = $2, tsnc_url = $3, updated_at = NOW()
func (q *Queries) AddGeneratedImages(ctx context.Context, arg AddGeneratedImagesParams) error {
	_, err := q.db.ExecContext(ctx, addGeneratedImages, arg.TalkSessionID, arg.WordmapUrl, arg.TsncUrl)
	return err
}

const getGeneratedImages = `-- name: GetGeneratedImages :one
SELECT
    talk_session_id,
    wordmap_url,
    tsnc_url,
    created_at,
    updated_at
FROM talk_session_generated_images
WHERE talk_session_id = $1::uuid
`

// GetGeneratedImages
//
//	SELECT
//	    talk_session_id,
//	    wordmap_url,
//	    tsnc_url,
//	    created_at,
//	    updated_at
//	FROM talk_session_generated_images
//	WHERE talk_session_id = $1::uuid
func (q *Queries) GetGeneratedImages(ctx context.Context, dollar_1 uuid.UUID) (TalkSessionGeneratedImage, error) {
	row := q.db.QueryRowContext(ctx, getGeneratedImages, dollar_1)
	var i TalkSessionGeneratedImage
	err := row.Scan(
		&i.TalkSessionID,
		&i.WordmapUrl,
		&i.TsncUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupInfoByTalkSessionId = `-- name: GetGroupInfoByTalkSessionId :many
SELECT
    user_group_info.pos_x,
    user_group_info.pos_y,
    user_group_info.group_id,
    user_group_info.perimeter_index,
    users.display_id AS display_id,
    users.display_name AS display_name,
    users.icon_url AS icon_url,
    user_group_info.user_id
FROM user_group_info
LEFT JOIN users
    ON user_group_info.user_id = users.user_id
WHERE talk_session_id = $1
`

type GetGroupInfoByTalkSessionIdRow struct {
	PosX           float64
	PosY           float64
	GroupID        int32
	PerimeterIndex sql.NullInt32
	DisplayID      sql.NullString
	DisplayName    sql.NullString
	IconUrl        sql.NullString
	UserID         uuid.UUID
}

// GetGroupInfoByTalkSessionId
//
//	SELECT
//	    user_group_info.pos_x,
//	    user_group_info.pos_y,
//	    user_group_info.group_id,
//	    user_group_info.perimeter_index,
//	    users.display_id AS display_id,
//	    users.display_name AS display_name,
//	    users.icon_url AS icon_url,
//	    user_group_info.user_id
//	FROM user_group_info
//	LEFT JOIN users
//	    ON user_group_info.user_id = users.user_id
//	WHERE talk_session_id = $1
func (q *Queries) GetGroupInfoByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]GetGroupInfoByTalkSessionIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupInfoByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupInfoByTalkSessionIdRow
	for rows.Next() {
		var i GetGroupInfoByTalkSessionIdRow
		if err := rows.Scan(
			&i.PosX,
			&i.PosY,
			&i.GroupID,
			&i.PerimeterIndex,
			&i.DisplayID,
			&i.DisplayName,
			&i.IconUrl,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupListByTalkSessionId = `-- name: GetGroupListByTalkSessionId :many
SELECT
    DISTINCT user_group_info.group_id
FROM user_group_info
WHERE talk_session_id = $1
`

// GetGroupListByTalkSessionId
//
//	SELECT
//	    DISTINCT user_group_info.group_id
//	FROM user_group_info
//	WHERE talk_session_id = $1
func (q *Queries) GetGroupListByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getGroupListByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var group_id int32
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByTalkSessionId = `-- name: GetReportByTalkSessionId :one
SELECT
    talk_session_id,
    report,
    created_at,
    updated_at
FROM talk_session_reports
WHERE talk_session_id = $1
`

// GetReportByTalkSessionId
//
//	SELECT
//	    talk_session_id,
//	    report,
//	    created_at,
//	    updated_at
//	FROM talk_session_reports
//	WHERE talk_session_id = $1
func (q *Queries) GetReportByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) (TalkSessionReport, error) {
	row := q.db.QueryRowContext(ctx, getReportByTalkSessionId, talkSessionID)
	var i TalkSessionReport
	err := row.Scan(
		&i.TalkSessionID,
		&i.Report,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRepresentativeOpinionsByTalkSessionId = `-- name: GetRepresentativeOpinionsByTalkSessionId :many
SELECT
    representative_opinions.talk_session_id, representative_opinions.opinion_id, representative_opinions.group_id, representative_opinions.rank, representative_opinions.updated_at, representative_opinions.created_at, representative_opinions.agree_count, representative_opinions.disagree_count, representative_opinions.pass_count,
    opinions.opinion_id, opinions.talk_session_id, opinions.user_id, opinions.parent_opinion_id, opinions.title, opinions.content, opinions.created_at, opinions.picture_url, opinions.reference_url,
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at,
    COALESCE(rc.reply_count, 0) AS reply_count
FROM representative_opinions
LEFT JOIN opinions
    ON representative_opinions.opinion_id = opinions.opinion_id
LEFT JOIN users
    ON opinions.user_id = users.user_id
LEFT JOIN (
    SELECT COUNT(opinion_id) AS reply_count, parent_opinion_id
    FROM opinions
    GROUP BY parent_opinion_id
) rc ON opinions.opinion_id = rc.parent_opinion_id
WHERE representative_opinions.rank < 4
    AND opinions.talk_session_id = $1
ORDER BY representative_opinions.rank
`

type GetRepresentativeOpinionsByTalkSessionIdRow struct {
	RepresentativeOpinion RepresentativeOpinion
	Opinion               Opinion
	User                  User
	ReplyCount            int64
}

// GetRepresentativeOpinionsByTalkSessionId
//
//	SELECT
//	    representative_opinions.talk_session_id, representative_opinions.opinion_id, representative_opinions.group_id, representative_opinions.rank, representative_opinions.updated_at, representative_opinions.created_at, representative_opinions.agree_count, representative_opinions.disagree_count, representative_opinions.pass_count,
//	    opinions.opinion_id, opinions.talk_session_id, opinions.user_id, opinions.parent_opinion_id, opinions.title, opinions.content, opinions.created_at, opinions.picture_url, opinions.reference_url,
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at,
//	    COALESCE(rc.reply_count, 0) AS reply_count
//	FROM representative_opinions
//	LEFT JOIN opinions
//	    ON representative_opinions.opinion_id = opinions.opinion_id
//	LEFT JOIN users
//	    ON opinions.user_id = users.user_id
//	LEFT JOIN (
//	    SELECT COUNT(opinion_id) AS reply_count, parent_opinion_id
//	    FROM opinions
//	    GROUP BY parent_opinion_id
//	) rc ON opinions.opinion_id = rc.parent_opinion_id
//	WHERE representative_opinions.rank < 4
//	    AND opinions.talk_session_id = $1
//	ORDER BY representative_opinions.rank
func (q *Queries) GetRepresentativeOpinionsByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]GetRepresentativeOpinionsByTalkSessionIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepresentativeOpinionsByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepresentativeOpinionsByTalkSessionIdRow
	for rows.Next() {
		var i GetRepresentativeOpinionsByTalkSessionIdRow
		if err := rows.Scan(
			&i.RepresentativeOpinion.TalkSessionID,
			&i.RepresentativeOpinion.OpinionID,
			&i.RepresentativeOpinion.GroupID,
			&i.RepresentativeOpinion.Rank,
			&i.RepresentativeOpinion.UpdatedAt,
			&i.RepresentativeOpinion.CreatedAt,
			&i.RepresentativeOpinion.AgreeCount,
			&i.RepresentativeOpinion.DisagreeCount,
			&i.RepresentativeOpinion.PassCount,
			&i.Opinion.OpinionID,
			&i.Opinion.TalkSessionID,
			&i.Opinion.UserID,
			&i.Opinion.ParentOpinionID,
			&i.Opinion.Title,
			&i.Opinion.Content,
			&i.Opinion.CreatedAt,
			&i.Opinion.PictureUrl,
			&i.Opinion.ReferenceUrl,
			&i.User.UserID,
			&i.User.DisplayID,
			&i.User.DisplayName,
			&i.User.IconUrl,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.ReplyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
