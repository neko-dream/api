// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analysis.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addGeneratedImages = `-- name: AddGeneratedImages :exec
INSERT INTO talk_session_generated_images (talk_session_id, wordmap_url, tsnc_url) VALUES ($1, $2, $3)
ON CONFLICT (talk_session_id) DO UPDATE SET wordmap_url = $2, tsnc_url = $3, updated_at = NOW()
`

type AddGeneratedImagesParams struct {
	TalkSessionID uuid.UUID
	WordmapUrl    string
	TsncUrl       string
}

// AddGeneratedImages
//
//	INSERT INTO talk_session_generated_images (talk_session_id, wordmap_url, tsnc_url) VALUES ($1, $2, $3)
//	ON CONFLICT (talk_session_id) DO UPDATE SET wordmap_url = $2, tsnc_url = $3, updated_at = NOW()
func (q *Queries) AddGeneratedImages(ctx context.Context, arg AddGeneratedImagesParams) error {
	_, err := q.db.ExecContext(ctx, addGeneratedImages, arg.TalkSessionID, arg.WordmapUrl, arg.TsncUrl)
	return err
}

const findReportByID = `-- name: FindReportByID :one
SELECT
    -- talk_session_report_history_id as analysis_report_history_id,
    talk_session_id,
    report,
    created_at
FROM talk_session_reports
WHERE talk_session_id = $1
`

type FindReportByIDRow struct {
	TalkSessionID uuid.UUID
	Report        string
	CreatedAt     time.Time
}

// FindReportByID
//
//	SELECT
//	    -- talk_session_report_history_id as analysis_report_history_id,
//	    talk_session_id,
//	    report,
//	    created_at
//	FROM talk_session_reports
//	WHERE talk_session_id = $1
func (q *Queries) FindReportByID(ctx context.Context, talkSessionID uuid.UUID) (FindReportByIDRow, error) {
	row := q.db.QueryRowContext(ctx, findReportByID, talkSessionID)
	var i FindReportByIDRow
	err := row.Scan(&i.TalkSessionID, &i.Report, &i.CreatedAt)
	return i, err
}

const getFeedbackByReportHistoryID = `-- name: GetFeedbackByReportHistoryID :many
SELECT
    report_feedback_id,
    user_id,
    feedback_type,
    created_at
FROM report_feedback
WHERE talk_session_report_history_id = $1
`

type GetFeedbackByReportHistoryIDRow struct {
	ReportFeedbackID uuid.UUID
	UserID           uuid.UUID
	FeedbackType     int32
	CreatedAt        time.Time
}

// GetFeedbackByReportHistoryID
//
//	SELECT
//	    report_feedback_id,
//	    user_id,
//	    feedback_type,
//	    created_at
//	FROM report_feedback
//	WHERE talk_session_report_history_id = $1
func (q *Queries) GetFeedbackByReportHistoryID(ctx context.Context, talkSessionReportHistoryID uuid.UUID) ([]GetFeedbackByReportHistoryIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedbackByReportHistoryID, talkSessionReportHistoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedbackByReportHistoryIDRow
	for rows.Next() {
		var i GetFeedbackByReportHistoryIDRow
		if err := rows.Scan(
			&i.ReportFeedbackID,
			&i.UserID,
			&i.FeedbackType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedImages = `-- name: GetGeneratedImages :one
SELECT
    talk_session_id,
    wordmap_url,
    tsnc_url,
    created_at,
    updated_at
FROM talk_session_generated_images
WHERE talk_session_id = $1::uuid
`

// GetGeneratedImages
//
//	SELECT
//	    talk_session_id,
//	    wordmap_url,
//	    tsnc_url,
//	    created_at,
//	    updated_at
//	FROM talk_session_generated_images
//	WHERE talk_session_id = $1::uuid
func (q *Queries) GetGeneratedImages(ctx context.Context, dollar_1 uuid.UUID) (TalkSessionGeneratedImage, error) {
	row := q.db.QueryRowContext(ctx, getGeneratedImages, dollar_1)
	var i TalkSessionGeneratedImage
	err := row.Scan(
		&i.TalkSessionID,
		&i.WordmapUrl,
		&i.TsncUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupInfoByTalkSessionId = `-- name: GetGroupInfoByTalkSessionId :many
SELECT
    user_group_info.pos_x,
    user_group_info.pos_y,
    user_group_info.group_id,
    user_group_info.perimeter_index,
    users.display_id AS display_id,
    users.display_name AS display_name,
    users.icon_url AS icon_url,
    user_group_info.user_id
FROM user_group_info
LEFT JOIN users
    ON user_group_info.user_id = users.user_id
WHERE talk_session_id = $1
`

type GetGroupInfoByTalkSessionIdRow struct {
	PosX           float64
	PosY           float64
	GroupID        int32
	PerimeterIndex sql.NullInt32
	DisplayID      sql.NullString
	DisplayName    sql.NullString
	IconUrl        sql.NullString
	UserID         uuid.UUID
}

// GetGroupInfoByTalkSessionId
//
//	SELECT
//	    user_group_info.pos_x,
//	    user_group_info.pos_y,
//	    user_group_info.group_id,
//	    user_group_info.perimeter_index,
//	    users.display_id AS display_id,
//	    users.display_name AS display_name,
//	    users.icon_url AS icon_url,
//	    user_group_info.user_id
//	FROM user_group_info
//	LEFT JOIN users
//	    ON user_group_info.user_id = users.user_id
//	WHERE talk_session_id = $1
func (q *Queries) GetGroupInfoByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]GetGroupInfoByTalkSessionIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupInfoByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupInfoByTalkSessionIdRow
	for rows.Next() {
		var i GetGroupInfoByTalkSessionIdRow
		if err := rows.Scan(
			&i.PosX,
			&i.PosY,
			&i.GroupID,
			&i.PerimeterIndex,
			&i.DisplayID,
			&i.DisplayName,
			&i.IconUrl,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupListByTalkSessionId = `-- name: GetGroupListByTalkSessionId :many
SELECT
    DISTINCT user_group_info.group_id
FROM user_group_info
WHERE talk_session_id = $1
`

// GetGroupListByTalkSessionId
//
//	SELECT
//	    DISTINCT user_group_info.group_id
//	FROM user_group_info
//	WHERE talk_session_id = $1
func (q *Queries) GetGroupListByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getGroupListByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var group_id int32
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportByTalkSessionId = `-- name: GetReportByTalkSessionId :one
SELECT
    -- talk_session_report_history_id as analysis_report_history_id,
    talk_session_id,
    report,
    created_at
FROM talk_session_reports
WHERE talk_session_id = $1
`

type GetReportByTalkSessionIdRow struct {
	TalkSessionID uuid.UUID
	Report        string
	CreatedAt     time.Time
}

// GetReportByTalkSessionId
//
//	SELECT
//	    -- talk_session_report_history_id as analysis_report_history_id,
//	    talk_session_id,
//	    report,
//	    created_at
//	FROM talk_session_reports
//	WHERE talk_session_id = $1
func (q *Queries) GetReportByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) (GetReportByTalkSessionIdRow, error) {
	row := q.db.QueryRowContext(ctx, getReportByTalkSessionId, talkSessionID)
	var i GetReportByTalkSessionIdRow
	err := row.Scan(&i.TalkSessionID, &i.Report, &i.CreatedAt)
	return i, err
}

const getRepresentativeOpinionsByTalkSessionId = `-- name: GetRepresentativeOpinionsByTalkSessionId :many
SELECT
    representative_opinions.talk_session_id, representative_opinions.opinion_id, representative_opinions.group_id, representative_opinions.rank, representative_opinions.updated_at, representative_opinions.created_at, representative_opinions.agree_count, representative_opinions.disagree_count, representative_opinions.pass_count,
    opinions.opinion_id, opinions.talk_session_id, opinions.user_id, opinions.parent_opinion_id, opinions.title, opinions.content, opinions.created_at, opinions.picture_url, opinions.reference_url,
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
    COALESCE(rc.reply_count, 0) AS reply_count
FROM representative_opinions
LEFT JOIN opinions
    ON representative_opinions.opinion_id = opinions.opinion_id
LEFT JOIN users
    ON opinions.user_id = users.user_id
LEFT JOIN (
    SELECT COUNT(opinion_id) AS reply_count, parent_opinion_id
    FROM opinions
    GROUP BY parent_opinion_id
) rc ON opinions.opinion_id = rc.parent_opinion_id
WHERE representative_opinions.rank < 4
    AND opinions.talk_session_id = $1
ORDER BY representative_opinions.rank
`

type GetRepresentativeOpinionsByTalkSessionIdRow struct {
	RepresentativeOpinion RepresentativeOpinion
	Opinion               Opinion
	User                  User
	ReplyCount            int64
}

// GetRepresentativeOpinionsByTalkSessionId
//
//	SELECT
//	    representative_opinions.talk_session_id, representative_opinions.opinion_id, representative_opinions.group_id, representative_opinions.rank, representative_opinions.updated_at, representative_opinions.created_at, representative_opinions.agree_count, representative_opinions.disagree_count, representative_opinions.pass_count,
//	    opinions.opinion_id, opinions.talk_session_id, opinions.user_id, opinions.parent_opinion_id, opinions.title, opinions.content, opinions.created_at, opinions.picture_url, opinions.reference_url,
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
//	    COALESCE(rc.reply_count, 0) AS reply_count
//	FROM representative_opinions
//	LEFT JOIN opinions
//	    ON representative_opinions.opinion_id = opinions.opinion_id
//	LEFT JOIN users
//	    ON opinions.user_id = users.user_id
//	LEFT JOIN (
//	    SELECT COUNT(opinion_id) AS reply_count, parent_opinion_id
//	    FROM opinions
//	    GROUP BY parent_opinion_id
//	) rc ON opinions.opinion_id = rc.parent_opinion_id
//	WHERE representative_opinions.rank < 4
//	    AND opinions.talk_session_id = $1
//	ORDER BY representative_opinions.rank
func (q *Queries) GetRepresentativeOpinionsByTalkSessionId(ctx context.Context, talkSessionID uuid.UUID) ([]GetRepresentativeOpinionsByTalkSessionIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepresentativeOpinionsByTalkSessionId, talkSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepresentativeOpinionsByTalkSessionIdRow
	for rows.Next() {
		var i GetRepresentativeOpinionsByTalkSessionIdRow
		if err := rows.Scan(
			&i.RepresentativeOpinion.TalkSessionID,
			&i.RepresentativeOpinion.OpinionID,
			&i.RepresentativeOpinion.GroupID,
			&i.RepresentativeOpinion.Rank,
			&i.RepresentativeOpinion.UpdatedAt,
			&i.RepresentativeOpinion.CreatedAt,
			&i.RepresentativeOpinion.AgreeCount,
			&i.RepresentativeOpinion.DisagreeCount,
			&i.RepresentativeOpinion.PassCount,
			&i.Opinion.OpinionID,
			&i.Opinion.TalkSessionID,
			&i.Opinion.UserID,
			&i.Opinion.ParentOpinionID,
			&i.Opinion.Title,
			&i.Opinion.Content,
			&i.Opinion.CreatedAt,
			&i.Opinion.PictureUrl,
			&i.Opinion.ReferenceUrl,
			&i.User.UserID,
			&i.User.DisplayID,
			&i.User.DisplayName,
			&i.User.IconUrl,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Email,
			&i.User.EmailVerified,
			&i.User.WithdrawalDate,
			&i.ReplyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveReportFeedback = `-- name: SaveReportFeedback :exec
INSERT INTO report_feedback (
    report_feedback_id,
    talk_session_report_history_id,
    user_id,
    feedback_type,
    created_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) ON CONFLICT (user_id, talk_session_report_history_id) DO NOTHING
`

type SaveReportFeedbackParams struct {
	ReportFeedbackID           uuid.UUID
	TalkSessionReportHistoryID uuid.UUID
	UserID                     uuid.UUID
	FeedbackType               int32
	CreatedAt                  time.Time
}

// SaveReportFeedback
//
//	INSERT INTO report_feedback (
//	    report_feedback_id,
//	    talk_session_report_history_id,
//	    user_id,
//	    feedback_type,
//	    created_at
//	) VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5
//	) ON CONFLICT (user_id, talk_session_report_history_id) DO NOTHING
func (q *Queries) SaveReportFeedback(ctx context.Context, arg SaveReportFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, saveReportFeedback,
		arg.ReportFeedbackID,
		arg.TalkSessionReportHistoryID,
		arg.UserID,
		arg.FeedbackType,
		arg.CreatedAt,
	)
	return err
}
