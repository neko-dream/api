// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const anonymizeUser = `-- name: AnonymizeUser :exec
UPDATE "users" SET 
    display_id = 'deleted_user', 
    display_name = '削除されたユーザー', 
    icon_url = NULL 
WHERE user_id = $1
`

// AnonymizeUser
//
//	UPDATE "users" SET
//	    display_id = 'deleted_user',
//	    display_name = '削除されたユーザー',
//	    icon_url = NULL
//	WHERE user_id = $1
func (q *Queries) AnonymizeUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, anonymizeUser, userID)
	return err
}

const changeSubject = `-- name: ChangeSubject :exec
UPDATE "user_auths" SET subject = $2 WHERE user_id = $1
`

type ChangeSubjectParams struct {
	UserID  uuid.UUID
	Subject string
}

// ChangeSubject
//
//	UPDATE "user_auths" SET subject = $2 WHERE user_id = $1
func (q *Queries) ChangeSubject(ctx context.Context, arg ChangeSubjectParams) error {
	_, err := q.db.ExecContext(ctx, changeSubject, arg.UserID, arg.Subject)
	return err
}

const checkReregistrationAllowed = `-- name: CheckReregistrationAllowed :one
SELECT 
    CASE 
        WHEN withdrawal_date IS NULL THEN true
        WHEN withdrawal_date < NOW() - INTERVAL '30 days' THEN true
        ELSE false
    END as allowed
FROM "user_auths" 
WHERE subject = $1
`

// CheckReregistrationAllowed
//
//	SELECT
//	    CASE
//	        WHEN withdrawal_date IS NULL THEN true
//	        WHEN withdrawal_date < NOW() - INTERVAL '30 days' THEN true
//	        ELSE false
//	    END as allowed
//	FROM "user_auths"
//	WHERE subject = $1
func (q *Queries) CheckReregistrationAllowed(ctx context.Context, subject string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkReregistrationAllowed, subject)
	var allowed bool
	err := row.Scan(&allowed)
	return allowed, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (user_id, created_at, email, email_verified) VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	UserID        uuid.UUID
	CreatedAt     time.Time
	Email         sql.NullString
	EmailVerified bool
}

// CreateUser
//
//	INSERT INTO users (user_id, created_at, email, email_verified) VALUES ($1, $2, $3, $4)
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.UserID,
		arg.CreatedAt,
		arg.Email,
		arg.EmailVerified,
	)
	return err
}

const createUserAuth = `-- name: CreateUserAuth :exec
INSERT INTO user_auths (user_auth_id, user_id, provider, subject, created_at, is_verified) VALUES ($1, $2, $3, $4, $5, false)
`

type CreateUserAuthParams struct {
	UserAuthID uuid.UUID
	UserID     uuid.UUID
	Provider   string
	Subject    string
	CreatedAt  time.Time
}

// CreateUserAuth
//
//	INSERT INTO user_auths (user_auth_id, user_id, provider, subject, created_at, is_verified) VALUES ($1, $2, $3, $4, $5, false)
func (q *Queries) CreateUserAuth(ctx context.Context, arg CreateUserAuthParams) error {
	_, err := q.db.ExecContext(ctx, createUserAuth,
		arg.UserAuthID,
		arg.UserID,
		arg.Provider,
		arg.Subject,
		arg.CreatedAt,
	)
	return err
}

const getUserAuthByUserID = `-- name: GetUserAuthByUserID :one
SELECT
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date
FROM
    "user_auths"
WHERE
    user_id = $1
`

type GetUserAuthByUserIDRow struct {
	UserAuth UserAuth
}

// GetUserAuthByUserID
//
//	SELECT
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date
//	FROM
//	    "user_auths"
//	WHERE
//	    user_id = $1
func (q *Queries) GetUserAuthByUserID(ctx context.Context, userID uuid.UUID) (GetUserAuthByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthByUserID, userID)
	var i GetUserAuthByUserIDRow
	err := row.Scan(
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
		&i.UserAuth.WithdrawalDate,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified
FROM
    "users"
WHERE
    users.user_id = $1
`

type GetUserByIDRow struct {
	User User
}

// GetUserByID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified
//	FROM
//	    "users"
//	WHERE
//	    users.user_id = $1
func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
	)
	return i, err
}

const getUserBySubject = `-- name: GetUserBySubject :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified,
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date
FROM
    "users"
    JOIN "user_auths" ON "users".user_id = "user_auths".user_id
WHERE
    "user_auths".subject = $1
`

type GetUserBySubjectRow struct {
	User     User
	UserAuth UserAuth
}

// GetUserBySubject
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified,
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date
//	FROM
//	    "users"
//	    JOIN "user_auths" ON "users".user_id = "user_auths".user_id
//	WHERE
//	    "user_auths".subject = $1
func (q *Queries) GetUserBySubject(ctx context.Context, subject string) (GetUserBySubjectRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySubject, subject)
	var i GetUserBySubjectRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
		&i.UserAuth.WithdrawalDate,
	)
	return i, err
}

const getUserDemographicByUserID = `-- name: GetUserDemographicByUserID :one
SELECT
    user_demographics_id, user_id, date_of_birth, gender, city, created_at, updated_at, prefecture
FROM
    "user_demographics"
WHERE
    user_id = $1
`

// GetUserDemographicByUserID
//
//	SELECT
//	    user_demographics_id, user_id, date_of_birth, gender, city, created_at, updated_at, prefecture
//	FROM
//	    "user_demographics"
//	WHERE
//	    user_id = $1
func (q *Queries) GetUserDemographicByUserID(ctx context.Context, userID uuid.UUID) (UserDemographic, error) {
	row := q.db.QueryRowContext(ctx, getUserDemographicByUserID, userID)
	var i UserDemographic
	err := row.Scan(
		&i.UserDemographicsID,
		&i.UserID,
		&i.DateOfBirth,
		&i.Gender,
		&i.City,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Prefecture,
	)
	return i, err
}

const getUserDetailByID = `-- name: GetUserDetailByID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified,
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date,
    user_demographics.user_demographics_id, user_demographics.user_id, user_demographics.date_of_birth, user_demographics.gender, user_demographics.city, user_demographics.created_at, user_demographics.updated_at, user_demographics.prefecture
FROM
    users
LEFT JOIN user_auths ON users.user_id = user_auths.user_id
LEFT JOIN user_demographics ON users.user_id = user_demographics.user_id
WHERE
    users.user_id = $1
`

type GetUserDetailByIDRow struct {
	User            User
	UserAuth        UserAuth
	UserDemographic UserDemographic
}

// GetUserDetailByID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified,
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at, user_auths.withdrawal_date,
//	    user_demographics.user_demographics_id, user_demographics.user_id, user_demographics.date_of_birth, user_demographics.gender, user_demographics.city, user_demographics.created_at, user_demographics.updated_at, user_demographics.prefecture
//	FROM
//	    users
//	LEFT JOIN user_auths ON users.user_id = user_auths.user_id
//	LEFT JOIN user_demographics ON users.user_id = user_demographics.user_id
//	WHERE
//	    users.user_id = $1
func (q *Queries) GetUserDetailByID(ctx context.Context, userID uuid.UUID) (GetUserDetailByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetailByID, userID)
	var i GetUserDetailByIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
		&i.UserAuth.WithdrawalDate,
		&i.UserDemographic.UserDemographicsID,
		&i.UserDemographic.UserID,
		&i.UserDemographic.DateOfBirth,
		&i.UserDemographic.Gender,
		&i.UserDemographic.City,
		&i.UserDemographic.CreatedAt,
		&i.UserDemographic.UpdatedAt,
		&i.UserDemographic.Prefecture,
	)
	return i, err
}

const getWithdrawalDate = `-- name: GetWithdrawalDate :one
SELECT withdrawal_date FROM "user_auths" WHERE user_id = $1
`

// GetWithdrawalDate
//
//	SELECT withdrawal_date FROM "user_auths" WHERE user_id = $1
func (q *Queries) GetWithdrawalDate(ctx context.Context, userID uuid.UUID) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, getWithdrawalDate, userID)
	var withdrawal_date sql.NullTime
	err := row.Scan(&withdrawal_date)
	return withdrawal_date, err
}

const updateOrCreateUserDemographic = `-- name: UpdateOrCreateUserDemographic :exec
INSERT INTO user_demographics (
    user_demographics_id,
    user_id,
    date_of_birth,
    gender,
    city,
    prefecture,
    created_at,
    updated_at
) VALUES ($1, $2, $3, $4, $5, $6,  now(), now())
ON CONFLICT (user_id)
DO UPDATE SET
    date_of_birth = $3,
    gender = $4,
    city = $5,
    prefecture = $6,
    updated_at = now()
`

type UpdateOrCreateUserDemographicParams struct {
	UserDemographicsID uuid.UUID
	UserID             uuid.UUID
	DateOfBirth        sql.NullString
	Gender             sql.NullString
	City               sql.NullString
	Prefecture         sql.NullString
}

// UpdateOrCreateUserDemographic
//
//	INSERT INTO user_demographics (
//	    user_demographics_id,
//	    user_id,
//	    date_of_birth,
//	    gender,
//	    city,
//	    prefecture,
//	    created_at,
//	    updated_at
//	) VALUES ($1, $2, $3, $4, $5, $6,  now(), now())
//	ON CONFLICT (user_id)
//	DO UPDATE SET
//	    date_of_birth = $3,
//	    gender = $4,
//	    city = $5,
//	    prefecture = $6,
//	    updated_at = now()
func (q *Queries) UpdateOrCreateUserDemographic(ctx context.Context, arg UpdateOrCreateUserDemographicParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateUserDemographic,
		arg.UserDemographicsID,
		arg.UserID,
		arg.DateOfBirth,
		arg.Gender,
		arg.City,
		arg.Prefecture,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE "users" SET display_id = $2, display_name = $3, icon_url = $4, email = $5, email_verified = $6 WHERE user_id = $1
`

type UpdateUserParams struct {
	UserID        uuid.UUID
	DisplayID     sql.NullString
	DisplayName   sql.NullString
	IconUrl       sql.NullString
	Email         sql.NullString
	EmailVerified bool
}

// UpdateUser
//
//	UPDATE "users" SET display_id = $2, display_name = $3, icon_url = $4, email = $5, email_verified = $6 WHERE user_id = $1
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.UserID,
		arg.DisplayID,
		arg.DisplayName,
		arg.IconUrl,
		arg.Email,
		arg.EmailVerified,
	)
	return err
}

const userFindByDisplayID = `-- name: UserFindByDisplayID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified
FROM
    "users"
WHERE
    display_id = $1
`

type UserFindByDisplayIDRow struct {
	User User
}

// UserFindByDisplayID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified
//	FROM
//	    "users"
//	WHERE
//	    display_id = $1
func (q *Queries) UserFindByDisplayID(ctx context.Context, displayID sql.NullString) (UserFindByDisplayIDRow, error) {
	row := q.db.QueryRowContext(ctx, userFindByDisplayID, displayID)
	var i UserFindByDisplayIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
	)
	return i, err
}

const verifyUser = `-- name: VerifyUser :exec
UPDATE "user_auths" SET is_verified = true WHERE user_id = $1
`

// VerifyUser
//
//	UPDATE "user_auths" SET is_verified = true WHERE user_id = $1
func (q *Queries) VerifyUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, verifyUser, userID)
	return err
}

const withdrawUser = `-- name: WithdrawUser :exec
UPDATE "user_auths" SET withdrawal_date = $2 WHERE user_id = $1
`

type WithdrawUserParams struct {
	UserID         uuid.UUID
	WithdrawalDate sql.NullTime
}

// WithdrawUser
//
//	UPDATE "user_auths" SET withdrawal_date = $2 WHERE user_id = $1
func (q *Queries) WithdrawUser(ctx context.Context, arg WithdrawUserParams) error {
	_, err := q.db.ExecContext(ctx, withdrawUser, arg.UserID, arg.WithdrawalDate)
	return err
}
