// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const changeSubject = `-- name: ChangeSubject :exec
UPDATE "user_auths" SET subject = $2 WHERE user_id = $1
`

type ChangeSubjectParams struct {
	UserID  uuid.UUID
	Subject string
}

// ChangeSubject
//
//	UPDATE "user_auths" SET subject = $2 WHERE user_id = $1
func (q *Queries) ChangeSubject(ctx context.Context, arg ChangeSubjectParams) error {
	_, err := q.db.ExecContext(ctx, changeSubject, arg.UserID, arg.Subject)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (user_id, created_at, email, email_verified) VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	UserID        uuid.UUID
	CreatedAt     time.Time
	Email         sql.NullString
	EmailVerified bool
}

// CreateUser
//
//	INSERT INTO users (user_id, created_at, email, email_verified) VALUES ($1, $2, $3, $4)
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.UserID,
		arg.CreatedAt,
		arg.Email,
		arg.EmailVerified,
	)
	return err
}

const createUserAuth = `-- name: CreateUserAuth :exec
INSERT INTO user_auths (user_auth_id, user_id, provider, subject, created_at, is_verified) VALUES ($1, $2, $3, $4, $5, false)
`

type CreateUserAuthParams struct {
	UserAuthID uuid.UUID
	UserID     uuid.UUID
	Provider   string
	Subject    string
	CreatedAt  time.Time
}

// CreateUserAuth
//
//	INSERT INTO user_auths (user_auth_id, user_id, provider, subject, created_at, is_verified) VALUES ($1, $2, $3, $4, $5, false)
func (q *Queries) CreateUserAuth(ctx context.Context, arg CreateUserAuthParams) error {
	_, err := q.db.ExecContext(ctx, createUserAuth,
		arg.UserAuthID,
		arg.UserID,
		arg.Provider,
		arg.Subject,
		arg.CreatedAt,
	)
	return err
}

const createUserStatusChangeLog = `-- name: CreateUserStatusChangeLog :exec
INSERT INTO user_status_change_logs (
    user_status_change_logs_id,
    user_id,
    status,
    reason,
    changed_at,
    changed_by,
    ip_address,
    user_agent,
    additional_data
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateUserStatusChangeLogParams struct {
	UserStatusChangeLogsID uuid.UUID
	UserID                 uuid.UUID
	Status                 string
	Reason                 sql.NullString
	ChangedAt              time.Time
	ChangedBy              string
	IpAddress              pqtype.Inet
	UserAgent              sql.NullString
	AdditionalData         pqtype.NullRawMessage
}

// CreateUserStatusChangeLog
//
//	INSERT INTO user_status_change_logs (
//	    user_status_change_logs_id,
//	    user_id,
//	    status,
//	    reason,
//	    changed_at,
//	    changed_by,
//	    ip_address,
//	    user_agent,
//	    additional_data
//	) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
func (q *Queries) CreateUserStatusChangeLog(ctx context.Context, arg CreateUserStatusChangeLogParams) error {
	_, err := q.db.ExecContext(ctx, createUserStatusChangeLog,
		arg.UserStatusChangeLogsID,
		arg.UserID,
		arg.Status,
		arg.Reason,
		arg.ChangedAt,
		arg.ChangedBy,
		arg.IpAddress,
		arg.UserAgent,
		arg.AdditionalData,
	)
	return err
}

const findUserStatusChangeLogsByUserID = `-- name: FindUserStatusChangeLogsByUserID :many
SELECT
    user_status_change_logs_id,
    user_id,
    status,
    reason,
    changed_at,
    changed_by,
    ip_address,
    user_agent,
    additional_data,
    created_at
FROM user_status_change_logs
WHERE user_id = $1
ORDER BY changed_at DESC
`

// FindUserStatusChangeLogsByUserID
//
//	SELECT
//	    user_status_change_logs_id,
//	    user_id,
//	    status,
//	    reason,
//	    changed_at,
//	    changed_by,
//	    ip_address,
//	    user_agent,
//	    additional_data,
//	    created_at
//	FROM user_status_change_logs
//	WHERE user_id = $1
//	ORDER BY changed_at DESC
func (q *Queries) FindUserStatusChangeLogsByUserID(ctx context.Context, userID uuid.UUID) ([]UserStatusChangeLog, error) {
	rows, err := q.db.QueryContext(ctx, findUserStatusChangeLogsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserStatusChangeLog
	for rows.Next() {
		var i UserStatusChangeLog
		if err := rows.Scan(
			&i.UserStatusChangeLogsID,
			&i.UserID,
			&i.Status,
			&i.Reason,
			&i.ChangedAt,
			&i.ChangedBy,
			&i.IpAddress,
			&i.UserAgent,
			&i.AdditionalData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthByUserID = `-- name: GetUserAuthByUserID :one
SELECT
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at
FROM
    "user_auths"
WHERE
    user_id = $1
`

type GetUserAuthByUserIDRow struct {
	UserAuth UserAuth
}

// GetUserAuthByUserID
//
//	SELECT
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at
//	FROM
//	    "user_auths"
//	WHERE
//	    user_id = $1
func (q *Queries) GetUserAuthByUserID(ctx context.Context, userID uuid.UUID) (GetUserAuthByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthByUserID, userID)
	var i GetUserAuthByUserIDRow
	err := row.Scan(
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date
FROM
    "users"
WHERE
    users.user_id = $1
`

type GetUserByIDRow struct {
	User User
}

// GetUserByID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date
//	FROM
//	    "users"
//	WHERE
//	    users.user_id = $1
func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.WithdrawalDate,
	)
	return i, err
}

const getUserBySubject = `-- name: GetUserBySubject :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at
FROM
    "users"
    JOIN "user_auths" ON "users".user_id = "user_auths".user_id
WHERE
    "user_auths".subject = $1
`

type GetUserBySubjectRow struct {
	User     User
	UserAuth UserAuth
}

// GetUserBySubject
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at
//	FROM
//	    "users"
//	    JOIN "user_auths" ON "users".user_id = "user_auths".user_id
//	WHERE
//	    "user_auths".subject = $1
func (q *Queries) GetUserBySubject(ctx context.Context, subject string) (GetUserBySubjectRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySubject, subject)
	var i GetUserBySubjectRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.WithdrawalDate,
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
	)
	return i, err
}

const getUserDemographicByUserID = `-- name: GetUserDemographicByUserID :one
SELECT
    user_demographics_id, user_id, date_of_birth, gender, city, created_at, updated_at, prefecture
FROM
    "user_demographics"
WHERE
    user_id = $1
`

// GetUserDemographicByUserID
//
//	SELECT
//	    user_demographics_id, user_id, date_of_birth, gender, city, created_at, updated_at, prefecture
//	FROM
//	    "user_demographics"
//	WHERE
//	    user_id = $1
func (q *Queries) GetUserDemographicByUserID(ctx context.Context, userID uuid.UUID) (UserDemographic, error) {
	row := q.db.QueryRowContext(ctx, getUserDemographicByUserID, userID)
	var i UserDemographic
	err := row.Scan(
		&i.UserDemographicsID,
		&i.UserID,
		&i.DateOfBirth,
		&i.Gender,
		&i.City,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Prefecture,
	)
	return i, err
}

const getUserDetailByID = `-- name: GetUserDetailByID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at,
    user_demographics.user_demographics_id, user_demographics.user_id, user_demographics.date_of_birth, user_demographics.gender, user_demographics.city, user_demographics.created_at, user_demographics.updated_at, user_demographics.prefecture
FROM
    users
LEFT JOIN user_auths ON users.user_id = user_auths.user_id
LEFT JOIN user_demographics ON users.user_id = user_demographics.user_id
WHERE
    users.user_id = $1
`

type GetUserDetailByIDRow struct {
	User            User
	UserAuth        UserAuth
	UserDemographic UserDemographic
}

// GetUserDetailByID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date,
//	    user_auths.user_auth_id, user_auths.user_id, user_auths.provider, user_auths.subject, user_auths.is_verified, user_auths.created_at,
//	    user_demographics.user_demographics_id, user_demographics.user_id, user_demographics.date_of_birth, user_demographics.gender, user_demographics.city, user_demographics.created_at, user_demographics.updated_at, user_demographics.prefecture
//	FROM
//	    users
//	LEFT JOIN user_auths ON users.user_id = user_auths.user_id
//	LEFT JOIN user_demographics ON users.user_id = user_demographics.user_id
//	WHERE
//	    users.user_id = $1
func (q *Queries) GetUserDetailByID(ctx context.Context, userID uuid.UUID) (GetUserDetailByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserDetailByID, userID)
	var i GetUserDetailByIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.WithdrawalDate,
		&i.UserAuth.UserAuthID,
		&i.UserAuth.UserID,
		&i.UserAuth.Provider,
		&i.UserAuth.Subject,
		&i.UserAuth.IsVerified,
		&i.UserAuth.CreatedAt,
		&i.UserDemographic.UserDemographicsID,
		&i.UserDemographic.UserID,
		&i.UserDemographic.DateOfBirth,
		&i.UserDemographic.Gender,
		&i.UserDemographic.City,
		&i.UserDemographic.CreatedAt,
		&i.UserDemographic.UpdatedAt,
		&i.UserDemographic.Prefecture,
	)
	return i, err
}

const reactivateUser = `-- name: ReactivateUser :exec
UPDATE "users" SET withdrawal_date = NULL WHERE user_id = $1
`

// ReactivateUser
//
//	UPDATE "users" SET withdrawal_date = NULL WHERE user_id = $1
func (q *Queries) ReactivateUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, reactivateUser, userID)
	return err
}

const updateOrCreateUserDemographic = `-- name: UpdateOrCreateUserDemographic :exec
INSERT INTO user_demographics (
    user_demographics_id,
    user_id,
    date_of_birth,
    gender,
    city,
    prefecture,
    created_at,
    updated_at
) VALUES ($1, $2, $3, $4, $5, $6,  now(), now())
ON CONFLICT (user_id)
DO UPDATE SET
    date_of_birth = $3,
    gender = $4,
    city = $5,
    prefecture = $6,
    updated_at = now()
`

type UpdateOrCreateUserDemographicParams struct {
	UserDemographicsID uuid.UUID
	UserID             uuid.UUID
	DateOfBirth        sql.NullString
	Gender             sql.NullString
	City               sql.NullString
	Prefecture         sql.NullString
}

// UpdateOrCreateUserDemographic
//
//	INSERT INTO user_demographics (
//	    user_demographics_id,
//	    user_id,
//	    date_of_birth,
//	    gender,
//	    city,
//	    prefecture,
//	    created_at,
//	    updated_at
//	) VALUES ($1, $2, $3, $4, $5, $6,  now(), now())
//	ON CONFLICT (user_id)
//	DO UPDATE SET
//	    date_of_birth = $3,
//	    gender = $4,
//	    city = $5,
//	    prefecture = $6,
//	    updated_at = now()
func (q *Queries) UpdateOrCreateUserDemographic(ctx context.Context, arg UpdateOrCreateUserDemographicParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateUserDemographic,
		arg.UserDemographicsID,
		arg.UserID,
		arg.DateOfBirth,
		arg.Gender,
		arg.City,
		arg.Prefecture,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE "users" SET display_id = $2, display_name = $3, icon_url = $4, email = $5, email_verified = $6, withdrawal_date = $7 WHERE user_id = $1
`

type UpdateUserParams struct {
	UserID         uuid.UUID
	DisplayID      sql.NullString
	DisplayName    sql.NullString
	IconUrl        sql.NullString
	Email          sql.NullString
	EmailVerified  bool
	WithdrawalDate sql.NullTime
}

// UpdateUser
//
//	UPDATE "users" SET display_id = $2, display_name = $3, icon_url = $4, email = $5, email_verified = $6, withdrawal_date = $7 WHERE user_id = $1
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.UserID,
		arg.DisplayID,
		arg.DisplayName,
		arg.IconUrl,
		arg.Email,
		arg.EmailVerified,
		arg.WithdrawalDate,
	)
	return err
}

const updateUserEmailAndSubject = `-- name: UpdateUserEmailAndSubject :exec
UPDATE "users" SET email = $2 WHERE user_id = $1
`

type UpdateUserEmailAndSubjectParams struct {
	UserID uuid.UUID
	Email  sql.NullString
}

// UpdateUserEmailAndSubject
//
//	UPDATE "users" SET email = $2 WHERE user_id = $1
func (q *Queries) UpdateUserEmailAndSubject(ctx context.Context, arg UpdateUserEmailAndSubjectParams) error {
	_, err := q.db.ExecContext(ctx, updateUserEmailAndSubject, arg.UserID, arg.Email)
	return err
}

const userFindByDisplayID = `-- name: UserFindByDisplayID :one
SELECT
    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date
FROM
    "users"
WHERE
    display_id = $1
`

type UserFindByDisplayIDRow struct {
	User User
}

// UserFindByDisplayID
//
//	SELECT
//	    users.user_id, users.display_id, users.display_name, users.icon_url, users.created_at, users.updated_at, users.email, users.email_verified, users.withdrawal_date
//	FROM
//	    "users"
//	WHERE
//	    display_id = $1
func (q *Queries) UserFindByDisplayID(ctx context.Context, displayID sql.NullString) (UserFindByDisplayIDRow, error) {
	row := q.db.QueryRowContext(ctx, userFindByDisplayID, displayID)
	var i UserFindByDisplayIDRow
	err := row.Scan(
		&i.User.UserID,
		&i.User.DisplayID,
		&i.User.DisplayName,
		&i.User.IconUrl,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.EmailVerified,
		&i.User.WithdrawalDate,
	)
	return i, err
}

const verifyUser = `-- name: VerifyUser :exec
UPDATE "user_auths" SET is_verified = true WHERE user_id = $1
`

// VerifyUser
//
//	UPDATE "user_auths" SET is_verified = true WHERE user_id = $1
func (q *Queries) VerifyUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, verifyUser, userID)
	return err
}

const withdrawUser = `-- name: WithdrawUser :exec
UPDATE "users" SET withdrawal_date = $2 WHERE user_id = $1
`

type WithdrawUserParams struct {
	UserID         uuid.UUID
	WithdrawalDate sql.NullTime
}

// WithdrawUser
//
//	UPDATE "users" SET withdrawal_date = $2 WHERE user_id = $1
func (q *Queries) WithdrawUser(ctx context.Context, arg WithdrawUserParams) error {
	_, err := q.db.ExecContext(ctx, withdrawUser, arg.UserID, arg.WithdrawalDate)
	return err
}
